{"version":3,"sources":["../src/server.ts","../src/plugins/bybit.ts","../src/plugins/config.ts","../src/constants.ts","../src/dtos/market.dto.ts","../src/handlers/market.ts","../src/services/ton-api.service.ts","../src/helpers/wallets-data.helper.ts","../src/services/ton-proof.service.ts","../src/services/market.service.ts","../src/routes/market.ts","../../../packages/contracts/build/Brokerage/tact_Broker.ts","../src/dtos/ton-connect.dto.ts","../src/handlers/ton-connect.ts","../src/routes/ton-connect.ts","../src/routes/index.ts","../src/index.ts"],"names":["cors","helmet","jwt","redis","swagger","websocket","scalar","fastify","serializerCompiler","validatorCompiler","DefaultLogger","WebsocketClient","fp","bybitPlugin","server","logger","params","wsClient","bybit_default","z","NodeEnv","configSchema","configPlugin","config","config_default","CHAIN","KlineTopic","candlestickSchema","bybitResponseSchema","candlestickResponseSchema","candlesticksResponseSchema","klineMessageSchema","ZodError","Address","TonClient4","Buffer","TonApiService","_TonApiService","client","address","masterAt","result","Cell","WalletContractV1R1","WalletContractV1R2","WalletContractV1R3","WalletContractV2R1","WalletContractV2R2","WalletContractV3R1","WalletContractV3R2","WalletContractV4R2","contractAddress","WalletContractV4R1","args","wallet","data","code","knownWallets","loadWalletV1Data","loadWalletV2Data","loadWalletV3Data","loadWalletV4Data","contract","loadData","cs","seqno","publicKey","walletId","plugins","tryParsePublicKey","stateInit","sha256","loadStateInit","tweetnacl","tonProofPrefix","tonConnectPrefix","validAuthTime","TonProofService","payload","getWalletPublicKey","wantedPublicKey","wantedAddress","message","wc","ts","dl","msg","msgHash","fullMsg","MarketService","redisKeys","pipeline","results","topic24h","item","topic1m","parsedTopic24h","parsedTopic1m","isKlineOfInterest","topic","handleKlineTopic","request","reply","latestCandlestick","error","candlesticks","candlestick","handleKlineTopicWS","socket","bybit","topics","handleBybitResponse","mnemonicToPrivateKey","TonClient","WalletContractV4","beginCell","internal","toNano","Slice","Builder","TupleBuilder","Dictionary","routes","log","publicClient","keyPair","btcCandlestickPublisherWallet","stream","P","batches","shouldSkip","_","info","candlestickToPublish","v","ie","err","token","market_default","checkProofRequestSchema","fromNano","handleCheckProof","newToken","handleGenerateProofPayload","handleAccountInfo","network","account","ton_connect_default","routes_default","server_default","port","host","signal"],"mappings":"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","sourcesContent":["import cors from '@fastify/cors';\nimport helmet from '@fastify/helmet';\nimport jwt from '@fastify/jwt';\nimport redis from '@fastify/redis';\nimport swagger from '@fastify/swagger';\nimport websocket from '@fastify/websocket';\nimport scalar from '@scalar/fastify-api-reference';\nimport fastify from 'fastify';\nimport { serializerCompiler, validatorCompiler, type ZodTypeProvider } from 'fastify-type-provider-zod';\nimport * as plugins from './plugins';\nimport routes from './routes';\n\nconst server = fastify({\n  // http2: true,\n  logger: {\n    level: process.env.LOG_LEVEL,\n  },\n}).withTypeProvider<ZodTypeProvider>();\n\nserver.setValidatorCompiler(validatorCompiler);\nserver.setSerializerCompiler(serializerCompiler);\n\nawait server.register(plugins.config);\nawait server.register(cors, {\n  origin: '*',\n});\nawait server.register(helmet);\nawait server.register(jwt, {\n  secret: server.config.JWT_SECRET,\n});\nawait server.register(swagger, {\n  openapi: {\n    openapi: '3.0.0',\n    info: {\n      title: 'Test swagger',\n      description: 'Testing the Fastify swagger API',\n      version: '0.1.0',\n    },\n    servers: [\n      {\n        url: 'http://localhost:3000',\n        description: 'Development server',\n      },\n    ],\n    tags: [\n      { name: 'user', description: 'User related end-points' },\n      { name: 'code', description: 'Code related end-points' },\n    ],\n    components: {\n      securitySchemes: {\n        apiKey: {\n          type: 'apiKey',\n          name: 'apiKey',\n          in: 'header',\n        },\n      },\n    },\n    externalDocs: {\n      url: 'https://swagger.io',\n      description: 'Find more info here',\n    },\n  },\n});\nawait server.register(scalar, {\n  routePrefix: '/reference',\n  configuration: {\n    spec: {\n      content: () => server.swagger(),\n    },\n  },\n});\nawait server.register(websocket, {\n  options: {\n    maxPayload: 1048576,\n  },\n});\nawait server.register(redis, {\n  url: server.config.REDIS_URI,\n});\nawait server.register(plugins.bybit);\n\nserver.get('/', (_, reply) => reply.code(418).send({ message: 'I am a teapot' }));\nawait server.register(routes);\n\nawait server.ready();\n\nexport default server;\n","import { DefaultLogger, WebsocketClient } from 'bybit-api';\nimport type { FastifyPluginAsync } from 'fastify';\nimport fp from 'fastify-plugin';\n\nconst bybitPlugin: FastifyPluginAsync = async (server) => {\n  const logger = {\n    ...DefaultLogger,\n    silly: (...params: any) => console.log('silly', ...params),\n  };\n\n  const wsClient = new WebsocketClient(\n    {\n      market: 'v5',\n    },\n    // logger,\n  );\n\n  server.addHook('onClose', async () => {\n    wsClient.closeAll();\n  });\n\n  server.decorate('bybit', {\n    ws: wsClient,\n  });\n};\n\ndeclare module 'fastify' {\n  interface FastifyInstance {\n    bybit: {\n      ws: WebsocketClient;\n    };\n  }\n}\n\nexport default fp(bybitPlugin);\n","import 'dotenv/config';\nimport type { FastifyPluginAsync } from 'fastify';\nimport fp from 'fastify-plugin';\nimport z from 'zod';\n\nexport enum NodeEnv {\n  development = 'development',\n  test = 'test',\n  production = 'production',\n}\n\nconst configSchema = z.object({\n  NODE_ENV: z.nativeEnum(NodeEnv),\n  LOG_LEVEL: z.string(),\n  API_HOST: z.string(),\n  API_PORT: z.string(),\n  ALLOWED_ORIGINS: z.string(),\n  REDIS_URI: z.string(),\n  REDIS_TOKEN: z.string(),\n  COOKIE_SECRET: z.string(),\n  JWT_SECRET: z.string(),\n  RPC_PROVIDER_API_KEY: z.string(),\n  DATA_STREAM_ADDRESS: z.string(),\n  MNEMONIC: z.string(),\n});\n\nexport type Config = z.infer<typeof configSchema>;\n\nconst configPlugin: FastifyPluginAsync = async (server) => {\n  const config = configSchema.safeParse(process.env);\n\n  if (!config.success) {\n    throw new Error('.env file validation failed - ' + JSON.stringify(config.error, null, 2));\n  }\n  server.decorate('config', config.data);\n};\n\ndeclare module 'fastify' {\n  interface FastifyInstance {\n    config: Config;\n  }\n}\n\nexport default fp(configPlugin);\n","export enum CHAIN {\n  MAINNET = '-239',\n  TESTNET = '-3',\n}\n\nexport enum BybitKlineTopic {\n  BTCUSDT = 'kline.1.BTCUSDT',\n  ETHUSDT = 'kline.1.ETHUSDT',\n  BNBUSDT = 'kline.1.BNBUSDT',\n  SOLUSDT = 'kline.1.SOLUSDT',\n  TONUSDT = 'kline.1.TONUSDT',\n}\n\nexport enum RedisKey {\n  KlineBTC24H = 'kline:BTC:24h',\n  KlineBTC1m = 'kline:BTC:1m',\n  KlineETH24H = 'kline:ETH:24h',\n  KlineETH1m = 'kline:ETH:1m',\n  KlineTON24H = 'kline:TON:24h',\n  KlineTON1m = 'kline:TON:1m',\n  KlineSOL24H = 'kline:SOL:24h',\n  KlineSOL1m = 'kline:SOL:1m',\n  KlineBNB24H = 'kline:BNB:24h',\n  KlineBNB1m = 'kline:BNB:1m',\n  SubcribeRequest = 'subscribe:request',\n}\n","import z from 'zod';\n\nexport const KlineTopic = z.enum(['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'TONUSDT']);\n\nexport type TKlineTopic = z.infer<typeof KlineTopic>;\n\nexport const candlestickSchema = z.object({\n  start: z.number(),\n  end: z.number(),\n  interval: z.string(),\n  open: z.string(),\n  close: z.string(),\n  high: z.string(),\n  low: z.string(),\n  volume: z.string(),\n  turnover: z.string(),\n  confirm: z.boolean(),\n  timestamp: z.number(),\n});\n\nexport type CandlestickDto = z.infer<typeof candlestickSchema>;\n\nexport const bybitResponseSchema = z.object({\n  topic: z.string(),\n  data: z.array(candlestickSchema),\n  ts: z.number(),\n  type: z.string(),\n  wsKey: z.string(),\n});\n\nexport type BybitResponseDto = z.infer<typeof bybitResponseSchema>;\n\nexport const candlestickResponseSchema = z.object({\n  open: z.number(),\n  close: z.number(),\n  high: z.number(),\n  low: z.number(),\n  time: z.number(),\n});\nexport const candlesticksResponseSchema = z.array(candlestickResponseSchema);\n\nexport type CandlestickResponseDto = z.infer<typeof candlestickResponseSchema>;\nexport type CandlesticksResponseDto = z.infer<typeof candlesticksResponseSchema>;\n\nexport const klineMessageSchema = z.object({\n  op: z.enum(['subscribe']),\n  args: z.array(KlineTopic),\n});\n\nexport type SubcribeKlineTopicDto = z.infer<typeof klineMessageSchema>;\n","import { RedisKey } from '@/constants';\nimport {\n  KlineTopic,\n  klineMessageSchema,\n  type BybitResponseDto,\n  type CandlestickDto,\n  type CandlesticksResponseDto,\n  type TKlineTopic,\n} from '@/dtos/market.dto';\nimport type { WebSocket } from '@fastify/websocket';\nimport type { FastifyReply, FastifyRequest } from 'fastify';\n\nimport { ZodError } from 'zod';\nimport { MarketService } from '../services';\n\nconst isKlineOfInterest = (topic: string, data: BybitResponseDto) => data.topic === topic;\n\nexport const handleKlineTopic = async (\n  request: FastifyRequest<{ Params: { topic: TKlineTopic } }>,\n  reply: FastifyReply,\n) => {\n  const { redis } = request.server;\n  const { topic } = request.params;\n\n  let data: CandlestickDto[] = [];\n  let latestCandlestick: CandlestickDto | null = null;\n  let error: ZodError | undefined;\n\n  switch (topic) {\n    case KlineTopic.Enum.BTCUSDT:\n      try {\n        const result = await MarketService.parseKlineTopic(\n          [RedisKey.KlineBTC24H, RedisKey.KlineBTC1m],\n          redis,\n        );\n\n        data = result.confirmedCandlesticks;\n\n        latestCandlestick = result.latestCandlestick;\n      } catch (error) {\n        if (error instanceof ZodError) {\n          error = error;\n        }\n      }\n      break;\n    case KlineTopic.Enum.ETHUSDT:\n      try {\n        const result = await MarketService.parseKlineTopic(\n          [RedisKey.KlineETH24H, RedisKey.KlineETH1m],\n          redis,\n        );\n\n        data = result.confirmedCandlesticks;\n        latestCandlestick = result.latestCandlestick;\n      } catch (error) {\n        if (error instanceof ZodError) {\n          error = error;\n        }\n      }\n      break;\n    case KlineTopic.Enum.TONUSDT:\n      try {\n        const result = await MarketService.parseKlineTopic(\n          [RedisKey.KlineTON24H, RedisKey.KlineTON1m],\n          redis,\n        );\n\n        data = result.confirmedCandlesticks;\n        latestCandlestick = result.latestCandlestick;\n      } catch (error) {\n        if (error instanceof ZodError) {\n          error = error;\n        }\n      }\n      break;\n    case KlineTopic.Enum.SOLUSDT:\n      try {\n        const result = await MarketService.parseKlineTopic(\n          [RedisKey.KlineSOL24H, RedisKey.KlineSOL1m],\n          redis,\n        );\n\n        data = result.confirmedCandlesticks;\n        latestCandlestick = result.latestCandlestick;\n      } catch (error) {\n        if (error instanceof ZodError) {\n          error = error;\n        }\n      }\n      break;\n    case KlineTopic.Enum.BNBUSDT:\n      try {\n        const result = await MarketService.parseKlineTopic(\n          [RedisKey.KlineBNB24H, RedisKey.KlineBNB1m],\n          redis,\n        );\n\n        data = result.confirmedCandlesticks;\n        latestCandlestick = result.latestCandlestick;\n      } catch (error) {\n        if (error instanceof ZodError) {\n          error = error;\n        }\n      }\n      break;\n  }\n\n  if (error) {\n    return reply.status(400).send(error.errors);\n  }\n\n  const candlesticks: CandlesticksResponseDto = [];\n  for (const candlestick of data) {\n    candlesticks.push({\n      open: Number(candlestick.open),\n      close: Number(candlestick.close),\n      high: Number(candlestick.high),\n      low: Number(candlestick.low),\n      time: Number(candlestick.end.toString().slice(0, -3)),\n    });\n  }\n\n  return reply.code(200).send({\n    list: candlesticks,\n    latest: latestCandlestick\n      ? {\n          open: Number(latestCandlestick?.open),\n          close: Number(latestCandlestick?.close),\n          high: Number(latestCandlestick?.high),\n          low: Number(latestCandlestick?.low),\n          time: Number(latestCandlestick?.end.toString().slice(0, -3)),\n        }\n      : null,\n  });\n};\n\nexport const handleKlineTopicWS = async (socket: WebSocket, request: FastifyRequest) => {\n  const { bybit } = request.server;\n\n  socket.on('message', async (message) => {\n    try {\n      const data = klineMessageSchema.parse(JSON.parse(message.toString()));\n\n      const topics = data.args;\n\n      bybit.ws.on('update', (data: BybitResponseDto) => handleBybitResponse(socket, data, topics));\n    } catch (error) {\n      if (error instanceof ZodError) {\n        socket.send(\n          JSON.stringify({\n            error: error.format(),\n          }),\n        );\n        return;\n      }\n\n      // Handle parsing error\n      if (error instanceof Error) {\n        socket.send(\n          JSON.stringify({\n            error: 'Invalid JSON payload',\n          }),\n        );\n      }\n    }\n  });\n};\n\nconst handleBybitResponse = (socket: WebSocket, data: BybitResponseDto, topics: TKlineTopic[]) => {\n  for (const topic of topics) {\n    if (isKlineOfInterest(`kline.1.${topic}`, data)) {\n      for (const candlestick of data.data) {\n        socket.send(\n          JSON.stringify({\n            topic: topic,\n            data: {\n              high: Number(candlestick.high),\n              low: Number(candlestick.low),\n              open: Number(candlestick.open),\n              close: Number(candlestick.close),\n              time: Number(candlestick.end.toString().slice(0, -3)),\n            },\n          }),\n        );\n      }\n    }\n  }\n};\n","import { Address, TonClient4 } from '@ton/ton';\nimport { CHAIN } from '@/constants';\nimport { Buffer } from 'buffer';\n\n// TODO: TonClient?\n\nexport class TonApiService {\n  public static create(client: TonClient4 | CHAIN): TonApiService {\n    if (client === CHAIN.MAINNET) {\n      client = new TonClient4({\n        endpoint: 'https://mainnet-v4.tonhubapi.com',\n      });\n    }\n    if (client === CHAIN.TESTNET) {\n      client = new TonClient4({\n        endpoint: 'https://testnet-v4.tonhubapi.com',\n      });\n    }\n    return new TonApiService(client);\n  }\n\n  private readonly client: TonClient4;\n\n  private constructor(client: TonClient4) {\n    this.client = client;\n  }\n\n  /**\n   * Get wallet public key by address.\n   */\n  public async getWalletPublicKey(address: string): Promise<Buffer> {\n    const masterAt = await this.client.getLastBlock();\n    const result = await this.client.runMethod(\n      masterAt.last.seqno,\n      Address.parse(address),\n      'get_public_key',\n      [],\n    );\n    return Buffer.from(result.reader.readBigNumber().toString(16).padStart(64, '0'), 'hex');\n  }\n\n  /**\n   * Get account info by address.\n   */\n  public async getAccountInfo(address: string): Promise<ReturnType<TonClient4['getAccount']>> {\n    const masterAt = await this.client.getLastBlock();\n    return await this.client.getAccount(masterAt.last.seqno, Address.parse(address));\n  }\n}\n","import {\n  Cell,\n  Slice,\n  WalletContractV1R1,\n  WalletContractV1R2,\n  WalletContractV1R3,\n  WalletContractV2R1,\n  WalletContractV2R2,\n  WalletContractV3R1,\n  WalletContractV3R2,\n  WalletContractV4 as WalletContractV4R2,\n  contractAddress,\n  type StateInit,\n} from '@ton/ton';\nimport { Buffer } from 'buffer';\n\nexport class WalletContractV4R1 {\n  static create(args: { workchain: number; publicKey: Buffer; walletId?: number | null }) {\n    const wallet = WalletContractV4R2.create(args);\n    const { data } = wallet.init;\n    const code = Cell.fromBoc(\n      Buffer.from(\n        'B5EE9C72410215010002F5000114FF00F4A413F4BCF2C80B010201200203020148040504F8F28308D71820D31FD31FD31F02F823BBF263ED44D0D31FD31FD3FFF404D15143BAF2A15151BAF2A205F901541064F910F2A3F80024A4C8CB1F5240CB1F5230CBFF5210F400C9ED54F80F01D30721C0009F6C519320D74A96D307D402FB00E830E021C001E30021C002E30001C0039130E30D03A4C8CB1F12CB1FCBFF1112131403EED001D0D3030171B0915BE021D749C120915BE001D31F218210706C7567BD228210626C6E63BDB022821064737472BDB0925F03E002FA403020FA4401C8CA07CBFFC9D0ED44D0810140D721F404305C810108F40A6FA131B3925F05E004D33FC8258210706C7567BA9131E30D248210626C6E63BAE30004060708020120090A005001FA00F404308210706C7567831EB17080185005CB0527CF165003FA02F40012CB69CB1F5210CB3F0052F8276F228210626C6E63831EB17080185005CB0527CF1624FA0214CB6A13CB1F5230CB3F01FA02F4000092821064737472BA8E3504810108F45930ED44D0810140D720C801CF16F400C9ED54821064737472831EB17080185004CB0558CF1622FA0212CB6ACB1FCB3F9410345F04E2C98040FB000201200B0C0059BD242B6F6A2684080A06B90FA0218470D4080847A4937D29910CE6903E9FF9837812801B7810148987159F31840201580D0E0011B8C97ED44D0D70B1F8003DB29DFB513420405035C87D010C00B23281F2FFF274006040423D029BE84C600201200F100019ADCE76A26840206B90EB85FFC00019AF1DF6A26840106B90EB858FC0006ED207FA00D4D422F90005C8CA0715CBFFC9D077748018C8CB05CB0222CF165005FA0214CB6B12CCCCC971FB00C84014810108F451F2A702006C810108D718C8542025810108F451F2A782106E6F746570748018C8CB05CB025004CF16821005F5E100FA0213CB6A12CB1FC971FB00020072810108D718305202810108F459F2A7F82582106473747270748018C8CB05CB025005CF16821005F5E100FA0214CB6A13CB1F12CB3FC973FB00000AF400C9ED5446A9F34F',\n        'hex',\n      ),\n    )[0]!;\n    (wallet as any).init = { data, code };\n    (wallet as any).address = contractAddress(args.workchain, wallet.init);\n    return wallet;\n  }\n}\n\nconst knownWallets = [\n  { contract: WalletContractV1R1, loadData: loadWalletV1Data },\n  { contract: WalletContractV1R2, loadData: loadWalletV1Data },\n  { contract: WalletContractV1R3, loadData: loadWalletV1Data },\n  { contract: WalletContractV2R1, loadData: loadWalletV2Data },\n  { contract: WalletContractV2R2, loadData: loadWalletV2Data },\n  { contract: WalletContractV3R1, loadData: loadWalletV3Data },\n  { contract: WalletContractV3R2, loadData: loadWalletV3Data },\n  { contract: WalletContractV4R1, loadData: loadWalletV4Data },\n  { contract: WalletContractV4R2, loadData: loadWalletV4Data },\n].map(({ contract, loadData }) => ({\n  contract: contract,\n  loadData: loadData,\n  wallet: contract.create({ workchain: 0, publicKey: Buffer.alloc(32) }),\n}));\n\nfunction loadWalletV1Data(cs: Slice) {\n  const seqno = cs.loadUint(32);\n  const publicKey = cs.loadBuffer(32);\n  return { seqno, publicKey };\n}\n\nfunction loadWalletV2Data(cs: Slice) {\n  const seqno = cs.loadUint(32);\n  const publicKey = cs.loadBuffer(32);\n  return { seqno, publicKey };\n}\n\nfunction loadWalletV3Data(cs: Slice) {\n  const seqno = cs.loadUint(32);\n  const walletId = cs.loadUint(32);\n  const publicKey = cs.loadBuffer(32);\n  return { seqno, publicKey, walletId };\n}\n\nfunction loadWalletV4Data(cs: Slice) {\n  const seqno = cs.loadUint(32);\n  const walletId = cs.loadUint(32);\n  const publicKey = cs.loadBuffer(32);\n  const plugins = cs.loadMaybeRef();\n  return { seqno, publicKey, walletId, plugins };\n}\n\nexport function tryParsePublicKey(stateInit: StateInit): Buffer | null {\n  if (!stateInit.code || !stateInit.data) {\n    return null;\n  }\n\n  for (const { wallet, loadData } of knownWallets) {\n    try {\n      if (wallet.init.code.equals(stateInit.code)) {\n        return loadData(stateInit.data.beginParse()).publicKey;\n      }\n    } catch (e) {}\n  }\n\n  return null;\n}\n","import type { CheckProofRequestDto } from '@/dtos/ton-connect.dto';\nimport { tryParsePublicKey } from '@/helpers/wallets-data.helper';\nimport { sha256 } from '@ton/crypto';\nimport { Address, Cell, contractAddress, loadStateInit } from '@ton/ton';\nimport { Buffer } from 'node:buffer';\n// TODO: Replace with node.js native crypto module\nimport tweetnacl from 'tweetnacl';\n\nconst tonProofPrefix = 'ton-proof-item-v2/';\nconst tonConnectPrefix = 'ton-connect';\nconst validAuthTime = 15 * 60; // 15 minutes\n\nexport class TonProofService {\n  /**\n   * Generate a random payload.\n   */\n  public generatePayload(): string {\n    return Buffer.from(tweetnacl.randomBytes(32)).toString('hex');\n  }\n\n  /**\n   * Reference implementation of the checkProof method:\n   * https://github.com/ton-blockchain/ton-connect/blob/main/requests-responses.md#address-proof-signature-ton_proof\n   */\n  public async checkProof(\n    payload: CheckProofRequestDto,\n    getWalletPublicKey: (address: string) => Promise<Buffer | null>,\n  ): Promise<boolean> {\n    try {\n      const stateInit = loadStateInit(Cell.fromBase64(payload.proof.state_init).beginParse());\n\n      // 1. First, try to obtain public key via get_public_key get-method on smart contract deployed at Address.\n      // 2. If the smart contract is not deployed yet, or the get-method is missing, you need:\n      //  2.1. Parse TonAddressItemReply.walletStateInit and get public key from stateInit. You can compare the walletStateInit.code\n      //  with the code of standard wallets contracts and parse the data according to the found wallet version.\n      let publicKey = tryParsePublicKey(stateInit) ?? (await getWalletPublicKey(payload.address));\n      if (!publicKey) {\n        return false;\n      }\n\n      // 2.2. Check that TonAddressItemReply.publicKey equals to obtained public key\n      const wantedPublicKey = Buffer.from(payload.public_key, 'hex');\n      if (!publicKey.equals(wantedPublicKey)) {\n        return false;\n      }\n\n      // 2.3. Check that TonAddressItemReply.walletStateInit.hash() equals to TonAddressItemReply.address. .hash() means BoC hash.\n      const wantedAddress = Address.parse(payload.address);\n      const address = contractAddress(wantedAddress.workChain, stateInit);\n      if (!address.equals(wantedAddress)) {\n        return false;\n      }\n\n      // if (!allowedDomains.includes(payload.proof.domain.value)) {\n      //   console.log('Invalid domain');\n\n      //   return false;\n      // }\n\n      const now = Math.floor(Date.now() / 1000);\n      if (now - validAuthTime > payload.proof.timestamp) {\n        return false;\n      }\n\n      const message = {\n        workchain: address.workChain,\n        address: address.hash,\n        domain: {\n          lengthBytes: payload.proof.domain.lengthBytes,\n          value: payload.proof.domain.value,\n        },\n        signature: Buffer.from(payload.proof.signature, 'base64'),\n        payload: payload.proof.payload,\n        stateInit: payload.proof.state_init,\n        timestamp: payload.proof.timestamp,\n      };\n\n      const wc = Buffer.alloc(4);\n      wc.writeUInt32BE(message.workchain, 0);\n\n      const ts = Buffer.alloc(8);\n      ts.writeBigUInt64LE(BigInt(message.timestamp), 0);\n\n      const dl = Buffer.alloc(4);\n      dl.writeUInt32LE(message.domain.lengthBytes, 0);\n\n      // message = utf8_encode(\"ton-proof-item-v2/\") ++\n      //           Address ++\n      //           AppDomain ++\n      //           Timestamp ++\n      //           Payload\n      const msg = Buffer.concat([\n        Buffer.from(tonProofPrefix),\n        wc,\n        message.address,\n        dl,\n        Buffer.from(message.domain.value),\n        ts,\n        Buffer.from(message.payload),\n      ]);\n\n      const msgHash = Buffer.from(await sha256(msg));\n\n      // signature = Ed25519Sign(privkey, sha256(0xffff ++ utf8_encode(\"ton-connect\") ++ sha256(message)))\n      const fullMsg = Buffer.concat([\n        Buffer.from([0xff, 0xff]),\n        Buffer.from(tonConnectPrefix),\n        msgHash,\n      ]);\n\n      const result = Buffer.from(await sha256(fullMsg));\n\n      return tweetnacl.sign.detached.verify(result, message.signature, publicKey);\n    } catch (e) {\n      return false;\n    }\n  }\n}\n","import { RedisKey } from '@/constants.js';\nimport { candlestickSchema, type CandlestickDto } from '@/dtos/market.dto.js';\nimport type { FastifyRedis } from '@fastify/redis';\nimport z from 'zod';\n\nexport class MarketService {\n  /**\n   * Parse kline topic\n   * @param redisKeys\n   * @param redis\n   *\n   * @throws {ZodError} when parsing fails\n   * @throws {Error} when fetching data fails\n   */\n  static async parseKlineTopic(\n    redisKeys: [RedisKey, RedisKey],\n    redis: FastifyRedis,\n  ): Promise<{ confirmedCandlesticks: CandlestickDto[]; latestCandlestick: CandlestickDto }> {\n    const pipeline = redis.pipeline();\n    pipeline.lrange(redisKeys[0], 0, -1);\n    pipeline.get(redisKeys[1]);\n    const results = await pipeline.exec();\n\n    if (!results) {\n      throw new Error('Failed to fetch data from Redis');\n    }\n\n    const topic24h = (results[0]?.[1] as string[]).map((item: string) => JSON.parse(item));\n    const topic1m = JSON.parse(results[1]?.[1] as string);\n\n    const parsedTopic24h = z.array(candlestickSchema).safeParse(topic24h);\n    const parsedTopic1m = candlestickSchema.safeParse(topic1m);\n\n    if (!parsedTopic24h.success || !parsedTopic1m.success) {\n      throw parsedTopic24h.error || parsedTopic1m.error;\n    }\n\n    return {\n      confirmedCandlesticks: parsedTopic24h.data,\n      latestCandlestick: parsedTopic1m.data,\n    };\n  }\n}\n","import { BybitKlineTopic, RedisKey } from '@/constants';\nimport { KlineTopic, type BybitResponseDto } from '@/dtos/market.dto';\nimport { handleKlineTopic, handleKlineTopicWS } from '@/handlers/market';\nimport { mnemonicToPrivateKey } from '@ton/crypto';\nimport { Address, TonClient, WalletContractV4, beginCell, internal } from '@ton/ton';\nimport type { FastifyPluginAsync } from 'fastify';\n\nimport { DataStream, storeDSTPublishCandlestick } from 'nenuma-contracts';\n\nimport z from 'zod';\n\nconst routes: FastifyPluginAsync = async (server) => {\n  const { redis, bybit, log } = server;\n\n  bybit.ws.subscribeV5(BybitKlineTopic.BTCUSDT, 'spot');\n\n  const publicClient = new TonClient({\n    endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC',\n    apiKey: server.config.RPC_PROVIDER_API_KEY,\n  });\n\n  const keyPair = await mnemonicToPrivateKey(server.config.MNEMONIC.split(','));\n\n  const workchain = 0; // Usually you need a workchain 0\n  const wallet = WalletContractV4.create({ workchain, publicKey: keyPair.publicKey });\n  const btcCandlestickPublisherWallet = publicClient.open(wallet);\n\n  const stream = publicClient.open(\n    DataStream.fromAddress(Address.parse(server.config.DATA_STREAM_ADDRESS)),\n  );\n\n  bybit.ws.on('update', async (data: BybitResponseDto) => {\n    switch (data.topic) {\n      case BybitKlineTopic.BTCUSDT:\n        for (const candlestick of data.data) {\n          if (candlestick.confirm) {\n            redis\n              .pipeline()\n              .rpush(RedisKey.KlineBTC24H, JSON.stringify(candlestick))\n              .ltrim(RedisKey.KlineBTC24H, -1440, -1)\n              .exec();\n\n            try {\n              const batches = await stream.getBatches();\n\n              let shouldSkip = false;\n              // Check if every batch is empty\n              for (const [_, info] of batches) {\n                log.debug('Batch Info: %s', info.subscriptionsCount.toString());\n                if (info.subscriptionsCount > 0) {\n                  shouldSkip = false;\n                } else {\n                  shouldSkip = true;\n                }\n              }\n\n              if (shouldSkip) {\n                return;\n              }\n\n              const seqno = await btcCandlestickPublisherWallet.getSeqno();\n\n              const candlestickToPublish = {\n                $$type: 'Candlestick' as const,\n                open: BigInt(candlestick.open.split('.').join('')),\n                high: BigInt(candlestick.high.split('.').join('')),\n                low: BigInt(candlestick.low.split('.').join('')),\n                close: BigInt(candlestick.close.split('.').join('')),\n                start: BigInt(candlestick.start.toString().slice(0, -3)),\n                end: BigInt(candlestick.end.toString().slice(0, -3)) + 1n,\n              };\n\n              log.debug(\n                'Publishing Candlestick: %s',\n                JSON.stringify(\n                  candlestickToPublish,\n                  (_, v) => (typeof v === 'bigint' ? v.toString() : v),\n                  2,\n                ),\n              );\n\n              await btcCandlestickPublisherWallet.sendTransfer({\n                seqno,\n                secretKey: keyPair.secretKey,\n                messages: [\n                  internal({\n                    value: '5',\n                    to: server.config.DATA_STREAM_ADDRESS,\n                    body: beginCell()\n                      .store(\n                        storeDSTPublishCandlestick({\n                          $$type: 'DSTPublishCandlestick',\n                          queryId: 777n,\n                          candlestick: candlestickToPublish,\n                        }),\n                      )\n                      .endCell(),\n                  }),\n                ],\n              });\n            } catch (error) {\n              log.error('Error: %s', error);\n            }\n          } else {\n            redis.set(RedisKey.KlineBTC1m, JSON.stringify(candlestick));\n          }\n        }\n        break;\n      // case BybitKlineTopic.ETHUSDT:\n      //   for (const candlestick of data.data) {\n      //     if (candlestick.confirm) {\n      //       redis\n      //         .pipeline()\n      //         .rpush(RedisKey.KlineETH24H, JSON.stringify(candlestick))\n      //         .ltrim(RedisKey.KlineETH24H, 0, 1439)\n      //         .exec();\n      //     } else {\n      //       redis.set(RedisKey.KlineETH1m, JSON.stringify(candlestick));\n      //     }\n      //   }\n      //   break;\n      // case BybitKlineTopic.BNBUSDT:\n      //   for (const candlestick of data.data) {\n      //     if (candlestick.confirm) {\n      //       redis\n      //         .pipeline()\n      //         .rpush(RedisKey.KlineBNB24H, JSON.stringify(candlestick))\n      //         .ltrim(RedisKey.KlineBNB24H, 0, 1439)\n      //         .exec();\n      //     } else {\n      //       redis.set(RedisKey.KlineBNB1m, JSON.stringify(candlestick));\n      //     }\n      //   }\n      //   break;\n      // case BybitKlineTopic.SOLUSDT:\n      //   for (const candlestick of data.data) {\n      //     if (candlestick.confirm) {\n      //       redis\n      //         .pipeline()\n      //         .rpush(RedisKey.KlineSOL24H, JSON.stringify(candlestick))\n      //         .ltrim(RedisKey.KlineSOL24H, 0, 1439)\n      //         .exec();\n      //     } else {\n      //       redis.set(RedisKey.KlineSOL1m, JSON.stringify(candlestick));\n      //     }\n      //   }\n      //   break;\n      // case BybitKlineTopic.TONUSDT:\n      //   for (const candlestick of data.data) {\n      //     if (candlestick.confirm) {\n      //       redis\n      //         .pipeline()\n      //         .rpush(RedisKey.KlineTON24H, JSON.stringify(candlestick))\n      //         .ltrim(RedisKey.KlineTON24H, 0, 1439)\n      //         .exec();\n      //     } else {\n      //       redis.set(RedisKey.KlineTON1m, JSON.stringify(candlestick));\n      //     }\n      //   }\n      //   break;\n    }\n  });\n\n  server.get(\n    '/kline/:topic',\n    {\n      schema: {\n        params: z.object({\n          topic: KlineTopic,\n        }),\n        querystring: z\n          .object({\n            token: z.string().optional(),\n          })\n          .optional(),\n      },\n      preHandler: async (request, reply) => {\n        try {\n          await request.jwtVerify();\n        } catch (err) {\n          reply.send(err);\n        }\n      },\n    },\n    handleKlineTopic,\n  );\n\n  server.get(\n    '/kline',\n    {\n      websocket: true,\n      preHandler: async (request, reply) => {\n        try {\n          if (request.query && typeof request.query === 'object' && 'token' in request.query) {\n            const { token } = request.query as { token: string };\n            request.headers.authorization = `Bearer ${token}`;\n          }\n          await request.jwtVerify();\n        } catch (err) {\n          reply.send(err);\n        }\n      },\n    },\n    handleKlineTopicWS,\n  );\n};\n\nexport default routes;\n","import { \n    Cell,\n    Slice, \n    Address, \n    Builder, \n    beginCell, \n    ComputeError, \n    TupleItem, \n    TupleReader, \n    Dictionary, \n    contractAddress, \n    ContractProvider, \n    Sender, \n    Contract, \n    ContractABI, \n    ABIType,\n    ABIGetter,\n    ABIReceiver,\n    TupleBuilder,\n    DictionaryValue\n} from '@ton/core';\n\nexport type StateInit = {\n    $$type: 'StateInit';\n    code: Cell;\n    data: Cell;\n}\n\nexport function storeStateInit(src: StateInit) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeRef(src.code);\n        b_0.storeRef(src.data);\n    };\n}\n\nexport function loadStateInit(slice: Slice) {\n    let sc_0 = slice;\n    let _code = sc_0.loadRef();\n    let _data = sc_0.loadRef();\n    return { $$type: 'StateInit' as const, code: _code, data: _data };\n}\n\nfunction loadTupleStateInit(source: TupleReader) {\n    let _code = source.readCell();\n    let _data = source.readCell();\n    return { $$type: 'StateInit' as const, code: _code, data: _data };\n}\n\nfunction storeTupleStateInit(source: StateInit) {\n    let builder = new TupleBuilder();\n    builder.writeCell(source.code);\n    builder.writeCell(source.data);\n    return builder.build();\n}\n\nfunction dictValueParserStateInit(): DictionaryValue<StateInit> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeStateInit(src)).endCell());\n        },\n        parse: (src) => {\n            return loadStateInit(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type Context = {\n    $$type: 'Context';\n    bounced: boolean;\n    sender: Address;\n    value: bigint;\n    raw: Cell;\n}\n\nexport function storeContext(src: Context) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeBit(src.bounced);\n        b_0.storeAddress(src.sender);\n        b_0.storeInt(src.value, 257);\n        b_0.storeRef(src.raw);\n    };\n}\n\nexport function loadContext(slice: Slice) {\n    let sc_0 = slice;\n    let _bounced = sc_0.loadBit();\n    let _sender = sc_0.loadAddress();\n    let _value = sc_0.loadIntBig(257);\n    let _raw = sc_0.loadRef();\n    return { $$type: 'Context' as const, bounced: _bounced, sender: _sender, value: _value, raw: _raw };\n}\n\nfunction loadTupleContext(source: TupleReader) {\n    let _bounced = source.readBoolean();\n    let _sender = source.readAddress();\n    let _value = source.readBigNumber();\n    let _raw = source.readCell();\n    return { $$type: 'Context' as const, bounced: _bounced, sender: _sender, value: _value, raw: _raw };\n}\n\nfunction storeTupleContext(source: Context) {\n    let builder = new TupleBuilder();\n    builder.writeBoolean(source.bounced);\n    builder.writeAddress(source.sender);\n    builder.writeNumber(source.value);\n    builder.writeSlice(source.raw);\n    return builder.build();\n}\n\nfunction dictValueParserContext(): DictionaryValue<Context> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeContext(src)).endCell());\n        },\n        parse: (src) => {\n            return loadContext(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SendParameters = {\n    $$type: 'SendParameters';\n    bounce: boolean;\n    to: Address;\n    value: bigint;\n    mode: bigint;\n    body: Cell | null;\n    code: Cell | null;\n    data: Cell | null;\n}\n\nexport function storeSendParameters(src: SendParameters) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeBit(src.bounce);\n        b_0.storeAddress(src.to);\n        b_0.storeInt(src.value, 257);\n        b_0.storeInt(src.mode, 257);\n        if (src.body !== null && src.body !== undefined) { b_0.storeBit(true).storeRef(src.body); } else { b_0.storeBit(false); }\n        if (src.code !== null && src.code !== undefined) { b_0.storeBit(true).storeRef(src.code); } else { b_0.storeBit(false); }\n        if (src.data !== null && src.data !== undefined) { b_0.storeBit(true).storeRef(src.data); } else { b_0.storeBit(false); }\n    };\n}\n\nexport function loadSendParameters(slice: Slice) {\n    let sc_0 = slice;\n    let _bounce = sc_0.loadBit();\n    let _to = sc_0.loadAddress();\n    let _value = sc_0.loadIntBig(257);\n    let _mode = sc_0.loadIntBig(257);\n    let _body = sc_0.loadBit() ? sc_0.loadRef() : null;\n    let _code = sc_0.loadBit() ? sc_0.loadRef() : null;\n    let _data = sc_0.loadBit() ? sc_0.loadRef() : null;\n    return { $$type: 'SendParameters' as const, bounce: _bounce, to: _to, value: _value, mode: _mode, body: _body, code: _code, data: _data };\n}\n\nfunction loadTupleSendParameters(source: TupleReader) {\n    let _bounce = source.readBoolean();\n    let _to = source.readAddress();\n    let _value = source.readBigNumber();\n    let _mode = source.readBigNumber();\n    let _body = source.readCellOpt();\n    let _code = source.readCellOpt();\n    let _data = source.readCellOpt();\n    return { $$type: 'SendParameters' as const, bounce: _bounce, to: _to, value: _value, mode: _mode, body: _body, code: _code, data: _data };\n}\n\nfunction storeTupleSendParameters(source: SendParameters) {\n    let builder = new TupleBuilder();\n    builder.writeBoolean(source.bounce);\n    builder.writeAddress(source.to);\n    builder.writeNumber(source.value);\n    builder.writeNumber(source.mode);\n    builder.writeCell(source.body);\n    builder.writeCell(source.code);\n    builder.writeCell(source.data);\n    return builder.build();\n}\n\nfunction dictValueParserSendParameters(): DictionaryValue<SendParameters> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSendParameters(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSendParameters(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type DSTDeploy = {\n    $$type: 'DSTDeploy';\n    queryId: bigint;\n}\n\nexport function storeDSTDeploy(src: DSTDeploy) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(306133030, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadDSTDeploy(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 306133030) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'DSTDeploy' as const, queryId: _queryId };\n}\n\nfunction loadTupleDSTDeploy(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'DSTDeploy' as const, queryId: _queryId };\n}\n\nfunction storeTupleDSTDeploy(source: DSTDeploy) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserDSTDeploy(): DictionaryValue<DSTDeploy> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeDSTDeploy(src)).endCell());\n        },\n        parse: (src) => {\n            return loadDSTDeploy(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type DSTDeploySuccess = {\n    $$type: 'DSTDeploySuccess';\n    queryId: bigint;\n}\n\nexport function storeDSTDeploySuccess(src: DSTDeploySuccess) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(3957924127, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadDSTDeploySuccess(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 3957924127) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'DSTDeploySuccess' as const, queryId: _queryId };\n}\n\nfunction loadTupleDSTDeploySuccess(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'DSTDeploySuccess' as const, queryId: _queryId };\n}\n\nfunction storeTupleDSTDeploySuccess(source: DSTDeploySuccess) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserDSTDeploySuccess(): DictionaryValue<DSTDeploySuccess> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeDSTDeploySuccess(src)).endCell());\n        },\n        parse: (src) => {\n            return loadDSTDeploySuccess(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type DSTDeployBatch = {\n    $$type: 'DSTDeployBatch';\n    queryId: bigint;\n}\n\nexport function storeDSTDeployBatch(src: DSTDeployBatch) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(3012477066, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadDSTDeployBatch(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 3012477066) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'DSTDeployBatch' as const, queryId: _queryId };\n}\n\nfunction loadTupleDSTDeployBatch(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'DSTDeployBatch' as const, queryId: _queryId };\n}\n\nfunction storeTupleDSTDeployBatch(source: DSTDeployBatch) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserDSTDeployBatch(): DictionaryValue<DSTDeployBatch> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeDSTDeployBatch(src)).endCell());\n        },\n        parse: (src) => {\n            return loadDSTDeployBatch(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type DSTDeployBatchSuccess = {\n    $$type: 'DSTDeployBatchSuccess';\n    queryId: bigint;\n    batch: Address;\n}\n\nexport function storeDSTDeployBatchSuccess(src: DSTDeployBatchSuccess) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(1261138638, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeAddress(src.batch);\n    };\n}\n\nexport function loadDSTDeployBatchSuccess(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 1261138638) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _batch = sc_0.loadAddress();\n    return { $$type: 'DSTDeployBatchSuccess' as const, queryId: _queryId, batch: _batch };\n}\n\nfunction loadTupleDSTDeployBatchSuccess(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _batch = source.readAddress();\n    return { $$type: 'DSTDeployBatchSuccess' as const, queryId: _queryId, batch: _batch };\n}\n\nfunction storeTupleDSTDeployBatchSuccess(source: DSTDeployBatchSuccess) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeAddress(source.batch);\n    return builder.build();\n}\n\nfunction dictValueParserDSTDeployBatchSuccess(): DictionaryValue<DSTDeployBatchSuccess> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeDSTDeployBatchSuccess(src)).endCell());\n        },\n        parse: (src) => {\n            return loadDSTDeployBatchSuccess(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type DSTDeploySession = {\n    $$type: 'DSTDeploySession';\n    queryId: bigint;\n}\n\nexport function storeDSTDeploySession(src: DSTDeploySession) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(1658160529, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadDSTDeploySession(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 1658160529) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'DSTDeploySession' as const, queryId: _queryId };\n}\n\nfunction loadTupleDSTDeploySession(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'DSTDeploySession' as const, queryId: _queryId };\n}\n\nfunction storeTupleDSTDeploySession(source: DSTDeploySession) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserDSTDeploySession(): DictionaryValue<DSTDeploySession> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeDSTDeploySession(src)).endCell());\n        },\n        parse: (src) => {\n            return loadDSTDeploySession(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type DSTDeploySessionSuccess = {\n    $$type: 'DSTDeploySessionSuccess';\n    queryId: bigint;\n    session: Address;\n}\n\nexport function storeDSTDeploySessionSuccess(src: DSTDeploySessionSuccess) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(3452518278, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeAddress(src.session);\n    };\n}\n\nexport function loadDSTDeploySessionSuccess(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 3452518278) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _session = sc_0.loadAddress();\n    return { $$type: 'DSTDeploySessionSuccess' as const, queryId: _queryId, session: _session };\n}\n\nfunction loadTupleDSTDeploySessionSuccess(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _session = source.readAddress();\n    return { $$type: 'DSTDeploySessionSuccess' as const, queryId: _queryId, session: _session };\n}\n\nfunction storeTupleDSTDeploySessionSuccess(source: DSTDeploySessionSuccess) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeAddress(source.session);\n    return builder.build();\n}\n\nfunction dictValueParserDSTDeploySessionSuccess(): DictionaryValue<DSTDeploySessionSuccess> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeDSTDeploySessionSuccess(src)).endCell());\n        },\n        parse: (src) => {\n            return loadDSTDeploySessionSuccess(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type DSTSubscribe = {\n    $$type: 'DSTSubscribe';\n    queryId: bigint;\n    subscriber: Address;\n    notificationsCount: bigint;\n}\n\nexport function storeDSTSubscribe(src: DSTSubscribe) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(3216336466, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeAddress(src.subscriber);\n        b_0.storeInt(src.notificationsCount, 257);\n    };\n}\n\nexport function loadDSTSubscribe(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 3216336466) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _subscriber = sc_0.loadAddress();\n    let _notificationsCount = sc_0.loadIntBig(257);\n    return { $$type: 'DSTSubscribe' as const, queryId: _queryId, subscriber: _subscriber, notificationsCount: _notificationsCount };\n}\n\nfunction loadTupleDSTSubscribe(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _subscriber = source.readAddress();\n    let _notificationsCount = source.readBigNumber();\n    return { $$type: 'DSTSubscribe' as const, queryId: _queryId, subscriber: _subscriber, notificationsCount: _notificationsCount };\n}\n\nfunction storeTupleDSTSubscribe(source: DSTSubscribe) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeAddress(source.subscriber);\n    builder.writeNumber(source.notificationsCount);\n    return builder.build();\n}\n\nfunction dictValueParserDSTSubscribe(): DictionaryValue<DSTSubscribe> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeDSTSubscribe(src)).endCell());\n        },\n        parse: (src) => {\n            return loadDSTSubscribe(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type DSTSubscribeSuccess = {\n    $$type: 'DSTSubscribeSuccess';\n    queryId: bigint;\n    batch: Address;\n    remainingNotificationsCount: bigint;\n}\n\nexport function storeDSTSubscribeSuccess(src: DSTSubscribeSuccess) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(3770107736, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeAddress(src.batch);\n        b_0.storeInt(src.remainingNotificationsCount, 257);\n    };\n}\n\nexport function loadDSTSubscribeSuccess(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 3770107736) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _batch = sc_0.loadAddress();\n    let _remainingNotificationsCount = sc_0.loadIntBig(257);\n    return { $$type: 'DSTSubscribeSuccess' as const, queryId: _queryId, batch: _batch, remainingNotificationsCount: _remainingNotificationsCount };\n}\n\nfunction loadTupleDSTSubscribeSuccess(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _batch = source.readAddress();\n    let _remainingNotificationsCount = source.readBigNumber();\n    return { $$type: 'DSTSubscribeSuccess' as const, queryId: _queryId, batch: _batch, remainingNotificationsCount: _remainingNotificationsCount };\n}\n\nfunction storeTupleDSTSubscribeSuccess(source: DSTSubscribeSuccess) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeAddress(source.batch);\n    builder.writeNumber(source.remainingNotificationsCount);\n    return builder.build();\n}\n\nfunction dictValueParserDSTSubscribeSuccess(): DictionaryValue<DSTSubscribeSuccess> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeDSTSubscribeSuccess(src)).endCell());\n        },\n        parse: (src) => {\n            return loadDSTSubscribeSuccess(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type Candlestick = {\n    $$type: 'Candlestick';\n    start: bigint;\n    end: bigint;\n    open: bigint;\n    close: bigint;\n    high: bigint;\n    low: bigint;\n}\n\nexport function storeCandlestick(src: Candlestick) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeInt(src.start, 257);\n        b_0.storeInt(src.end, 257);\n        b_0.storeInt(src.open, 257);\n        let b_1 = new Builder();\n        b_1.storeInt(src.close, 257);\n        b_1.storeInt(src.high, 257);\n        b_1.storeInt(src.low, 257);\n        b_0.storeRef(b_1.endCell());\n    };\n}\n\nexport function loadCandlestick(slice: Slice) {\n    let sc_0 = slice;\n    let _start = sc_0.loadIntBig(257);\n    let _end = sc_0.loadIntBig(257);\n    let _open = sc_0.loadIntBig(257);\n    let sc_1 = sc_0.loadRef().beginParse();\n    let _close = sc_1.loadIntBig(257);\n    let _high = sc_1.loadIntBig(257);\n    let _low = sc_1.loadIntBig(257);\n    return { $$type: 'Candlestick' as const, start: _start, end: _end, open: _open, close: _close, high: _high, low: _low };\n}\n\nfunction loadTupleCandlestick(source: TupleReader) {\n    let _start = source.readBigNumber();\n    let _end = source.readBigNumber();\n    let _open = source.readBigNumber();\n    let _close = source.readBigNumber();\n    let _high = source.readBigNumber();\n    let _low = source.readBigNumber();\n    return { $$type: 'Candlestick' as const, start: _start, end: _end, open: _open, close: _close, high: _high, low: _low };\n}\n\nfunction storeTupleCandlestick(source: Candlestick) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.start);\n    builder.writeNumber(source.end);\n    builder.writeNumber(source.open);\n    builder.writeNumber(source.close);\n    builder.writeNumber(source.high);\n    builder.writeNumber(source.low);\n    return builder.build();\n}\n\nfunction dictValueParserCandlestick(): DictionaryValue<Candlestick> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeCandlestick(src)).endCell());\n        },\n        parse: (src) => {\n            return loadCandlestick(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type DSTPublishCandlestick = {\n    $$type: 'DSTPublishCandlestick';\n    queryId: bigint;\n    candlestick: Candlestick;\n}\n\nexport function storeDSTPublishCandlestick(src: DSTPublishCandlestick) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(990592317, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.store(storeCandlestick(src.candlestick));\n    };\n}\n\nexport function loadDSTPublishCandlestick(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 990592317) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _candlestick = loadCandlestick(sc_0);\n    return { $$type: 'DSTPublishCandlestick' as const, queryId: _queryId, candlestick: _candlestick };\n}\n\nfunction loadTupleDSTPublishCandlestick(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    const _candlestick = loadTupleCandlestick(source.readTuple());\n    return { $$type: 'DSTPublishCandlestick' as const, queryId: _queryId, candlestick: _candlestick };\n}\n\nfunction storeTupleDSTPublishCandlestick(source: DSTPublishCandlestick) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeTuple(storeTupleCandlestick(source.candlestick));\n    return builder.build();\n}\n\nfunction dictValueParserDSTPublishCandlestick(): DictionaryValue<DSTPublishCandlestick> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeDSTPublishCandlestick(src)).endCell());\n        },\n        parse: (src) => {\n            return loadDSTPublishCandlestick(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type DSTPublishCandlestickSuccess = {\n    $$type: 'DSTPublishCandlestickSuccess';\n    queryId: bigint;\n}\n\nexport function storeDSTPublishCandlestickSuccess(src: DSTPublishCandlestickSuccess) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(215123525, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadDSTPublishCandlestickSuccess(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 215123525) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'DSTPublishCandlestickSuccess' as const, queryId: _queryId };\n}\n\nfunction loadTupleDSTPublishCandlestickSuccess(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'DSTPublishCandlestickSuccess' as const, queryId: _queryId };\n}\n\nfunction storeTupleDSTPublishCandlestickSuccess(source: DSTPublishCandlestickSuccess) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserDSTPublishCandlestickSuccess(): DictionaryValue<DSTPublishCandlestickSuccess> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeDSTPublishCandlestickSuccess(src)).endCell());\n        },\n        parse: (src) => {\n            return loadDSTPublishCandlestickSuccess(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type DSTUnsubscribedNotification = {\n    $$type: 'DSTUnsubscribedNotification';\n    queryId: bigint;\n    remainingNotificationsCount: bigint;\n}\n\nexport function storeDSTUnsubscribedNotification(src: DSTUnsubscribedNotification) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(1287102660, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeInt(src.remainingNotificationsCount, 257);\n    };\n}\n\nexport function loadDSTUnsubscribedNotification(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 1287102660) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _remainingNotificationsCount = sc_0.loadIntBig(257);\n    return { $$type: 'DSTUnsubscribedNotification' as const, queryId: _queryId, remainingNotificationsCount: _remainingNotificationsCount };\n}\n\nfunction loadTupleDSTUnsubscribedNotification(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _remainingNotificationsCount = source.readBigNumber();\n    return { $$type: 'DSTUnsubscribedNotification' as const, queryId: _queryId, remainingNotificationsCount: _remainingNotificationsCount };\n}\n\nfunction storeTupleDSTUnsubscribedNotification(source: DSTUnsubscribedNotification) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeNumber(source.remainingNotificationsCount);\n    return builder.build();\n}\n\nfunction dictValueParserDSTUnsubscribedNotification(): DictionaryValue<DSTUnsubscribedNotification> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeDSTUnsubscribedNotification(src)).endCell());\n        },\n        parse: (src) => {\n            return loadDSTUnsubscribedNotification(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SBDeploy = {\n    $$type: 'SBDeploy';\n    queryId: bigint;\n}\n\nexport function storeSBDeploy(src: SBDeploy) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(4267613765, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadSBDeploy(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 4267613765) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'SBDeploy' as const, queryId: _queryId };\n}\n\nfunction loadTupleSBDeploy(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'SBDeploy' as const, queryId: _queryId };\n}\n\nfunction storeTupleSBDeploy(source: SBDeploy) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserSBDeploy(): DictionaryValue<SBDeploy> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSBDeploy(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSBDeploy(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SBDeploySuccess = {\n    $$type: 'SBDeploySuccess';\n    queryId: bigint;\n    batchId: bigint;\n}\n\nexport function storeSBDeploySuccess(src: SBDeploySuccess) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(1031311118, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeInt(src.batchId, 257);\n    };\n}\n\nexport function loadSBDeploySuccess(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 1031311118) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _batchId = sc_0.loadIntBig(257);\n    return { $$type: 'SBDeploySuccess' as const, queryId: _queryId, batchId: _batchId };\n}\n\nfunction loadTupleSBDeploySuccess(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _batchId = source.readBigNumber();\n    return { $$type: 'SBDeploySuccess' as const, queryId: _queryId, batchId: _batchId };\n}\n\nfunction storeTupleSBDeploySuccess(source: SBDeploySuccess) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeNumber(source.batchId);\n    return builder.build();\n}\n\nfunction dictValueParserSBDeploySuccess(): DictionaryValue<SBDeploySuccess> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSBDeploySuccess(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSBDeploySuccess(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SBSubscribe = {\n    $$type: 'SBSubscribe';\n    queryId: bigint;\n    session: Address;\n    notificationsCount: bigint;\n}\n\nexport function storeSBSubscribe(src: SBSubscribe) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(2001551522, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeAddress(src.session);\n        b_0.storeInt(src.notificationsCount, 257);\n    };\n}\n\nexport function loadSBSubscribe(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 2001551522) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _session = sc_0.loadAddress();\n    let _notificationsCount = sc_0.loadIntBig(257);\n    return { $$type: 'SBSubscribe' as const, queryId: _queryId, session: _session, notificationsCount: _notificationsCount };\n}\n\nfunction loadTupleSBSubscribe(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _session = source.readAddress();\n    let _notificationsCount = source.readBigNumber();\n    return { $$type: 'SBSubscribe' as const, queryId: _queryId, session: _session, notificationsCount: _notificationsCount };\n}\n\nfunction storeTupleSBSubscribe(source: SBSubscribe) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeAddress(source.session);\n    builder.writeNumber(source.notificationsCount);\n    return builder.build();\n}\n\nfunction dictValueParserSBSubscribe(): DictionaryValue<SBSubscribe> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSBSubscribe(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSBSubscribe(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SBSubscribeSuccess = {\n    $$type: 'SBSubscribeSuccess';\n    queryId: bigint;\n    session: Address;\n    remainingNotificationsCount: bigint;\n}\n\nexport function storeSBSubscribeSuccess(src: SBSubscribeSuccess) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(4082513223, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeAddress(src.session);\n        b_0.storeInt(src.remainingNotificationsCount, 257);\n    };\n}\n\nexport function loadSBSubscribeSuccess(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 4082513223) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _session = sc_0.loadAddress();\n    let _remainingNotificationsCount = sc_0.loadIntBig(257);\n    return { $$type: 'SBSubscribeSuccess' as const, queryId: _queryId, session: _session, remainingNotificationsCount: _remainingNotificationsCount };\n}\n\nfunction loadTupleSBSubscribeSuccess(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _session = source.readAddress();\n    let _remainingNotificationsCount = source.readBigNumber();\n    return { $$type: 'SBSubscribeSuccess' as const, queryId: _queryId, session: _session, remainingNotificationsCount: _remainingNotificationsCount };\n}\n\nfunction storeTupleSBSubscribeSuccess(source: SBSubscribeSuccess) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeAddress(source.session);\n    builder.writeNumber(source.remainingNotificationsCount);\n    return builder.build();\n}\n\nfunction dictValueParserSBSubscribeSuccess(): DictionaryValue<SBSubscribeSuccess> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSBSubscribeSuccess(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSBSubscribeSuccess(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SBPublishCandlestick = {\n    $$type: 'SBPublishCandlestick';\n    queryId: bigint;\n    candlestick: Candlestick;\n    publisher: Address;\n}\n\nexport function storeSBPublishCandlestick(src: SBPublishCandlestick) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(4051052066, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.store(storeCandlestick(src.candlestick));\n        let b_1 = new Builder();\n        b_1.storeAddress(src.publisher);\n        b_0.storeRef(b_1.endCell());\n    };\n}\n\nexport function loadSBPublishCandlestick(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 4051052066) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _candlestick = loadCandlestick(sc_0);\n    let sc_1 = sc_0.loadRef().beginParse();\n    let _publisher = sc_1.loadAddress();\n    return { $$type: 'SBPublishCandlestick' as const, queryId: _queryId, candlestick: _candlestick, publisher: _publisher };\n}\n\nfunction loadTupleSBPublishCandlestick(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    const _candlestick = loadTupleCandlestick(source.readTuple());\n    let _publisher = source.readAddress();\n    return { $$type: 'SBPublishCandlestick' as const, queryId: _queryId, candlestick: _candlestick, publisher: _publisher };\n}\n\nfunction storeTupleSBPublishCandlestick(source: SBPublishCandlestick) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeTuple(storeTupleCandlestick(source.candlestick));\n    builder.writeAddress(source.publisher);\n    return builder.build();\n}\n\nfunction dictValueParserSBPublishCandlestick(): DictionaryValue<SBPublishCandlestick> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSBPublishCandlestick(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSBPublishCandlestick(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SBCandlestickPublishedNotification = {\n    $$type: 'SBCandlestickPublishedNotification';\n    queryId: bigint;\n    candlestick: Candlestick;\n    remainingNotificationsCount: bigint;\n}\n\nexport function storeSBCandlestickPublishedNotification(src: SBCandlestickPublishedNotification) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(4175431181, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.store(storeCandlestick(src.candlestick));\n        let b_1 = new Builder();\n        b_1.storeInt(src.remainingNotificationsCount, 257);\n        b_0.storeRef(b_1.endCell());\n    };\n}\n\nexport function loadSBCandlestickPublishedNotification(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 4175431181) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _candlestick = loadCandlestick(sc_0);\n    let sc_1 = sc_0.loadRef().beginParse();\n    let _remainingNotificationsCount = sc_1.loadIntBig(257);\n    return { $$type: 'SBCandlestickPublishedNotification' as const, queryId: _queryId, candlestick: _candlestick, remainingNotificationsCount: _remainingNotificationsCount };\n}\n\nfunction loadTupleSBCandlestickPublishedNotification(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    const _candlestick = loadTupleCandlestick(source.readTuple());\n    let _remainingNotificationsCount = source.readBigNumber();\n    return { $$type: 'SBCandlestickPublishedNotification' as const, queryId: _queryId, candlestick: _candlestick, remainingNotificationsCount: _remainingNotificationsCount };\n}\n\nfunction storeTupleSBCandlestickPublishedNotification(source: SBCandlestickPublishedNotification) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeTuple(storeTupleCandlestick(source.candlestick));\n    builder.writeNumber(source.remainingNotificationsCount);\n    return builder.build();\n}\n\nfunction dictValueParserSBCandlestickPublishedNotification(): DictionaryValue<SBCandlestickPublishedNotification> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSBCandlestickPublishedNotification(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSBCandlestickPublishedNotification(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SBUnsubscribedNotification = {\n    $$type: 'SBUnsubscribedNotification';\n    queryId: bigint;\n    session: Address;\n    remainingNotificationsCount: bigint;\n}\n\nexport function storeSBUnsubscribedNotification(src: SBUnsubscribedNotification) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(1003141156, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeAddress(src.session);\n        b_0.storeInt(src.remainingNotificationsCount, 257);\n    };\n}\n\nexport function loadSBUnsubscribedNotification(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 1003141156) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _session = sc_0.loadAddress();\n    let _remainingNotificationsCount = sc_0.loadIntBig(257);\n    return { $$type: 'SBUnsubscribedNotification' as const, queryId: _queryId, session: _session, remainingNotificationsCount: _remainingNotificationsCount };\n}\n\nfunction loadTupleSBUnsubscribedNotification(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _session = source.readAddress();\n    let _remainingNotificationsCount = source.readBigNumber();\n    return { $$type: 'SBUnsubscribedNotification' as const, queryId: _queryId, session: _session, remainingNotificationsCount: _remainingNotificationsCount };\n}\n\nfunction storeTupleSBUnsubscribedNotification(source: SBUnsubscribedNotification) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeAddress(source.session);\n    builder.writeNumber(source.remainingNotificationsCount);\n    return builder.build();\n}\n\nfunction dictValueParserSBUnsubscribedNotification(): DictionaryValue<SBUnsubscribedNotification> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSBUnsubscribedNotification(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSBUnsubscribedNotification(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SBPublishCandlestickSuccess = {\n    $$type: 'SBPublishCandlestickSuccess';\n    queryId: bigint;\n}\n\nexport function storeSBPublishCandlestickSuccess(src: SBPublishCandlestickSuccess) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(1027631690, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadSBPublishCandlestickSuccess(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 1027631690) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'SBPublishCandlestickSuccess' as const, queryId: _queryId };\n}\n\nfunction loadTupleSBPublishCandlestickSuccess(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'SBPublishCandlestickSuccess' as const, queryId: _queryId };\n}\n\nfunction storeTupleSBPublishCandlestickSuccess(source: SBPublishCandlestickSuccess) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserSBPublishCandlestickSuccess(): DictionaryValue<SBPublishCandlestickSuccess> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSBPublishCandlestickSuccess(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSBPublishCandlestickSuccess(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SESDeploy = {\n    $$type: 'SESDeploy';\n    queryId: bigint;\n}\n\nexport function storeSESDeploy(src: SESDeploy) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(1372687436, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadSESDeploy(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 1372687436) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'SESDeploy' as const, queryId: _queryId };\n}\n\nfunction loadTupleSESDeploy(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'SESDeploy' as const, queryId: _queryId };\n}\n\nfunction storeTupleSESDeploy(source: SESDeploy) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserSESDeploy(): DictionaryValue<SESDeploy> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSESDeploy(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSESDeploy(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SESDeploySuccess = {\n    $$type: 'SESDeploySuccess';\n    queryId: bigint;\n    subscriber: Address;\n}\n\nexport function storeSESDeploySuccess(src: SESDeploySuccess) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(269942218, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeAddress(src.subscriber);\n    };\n}\n\nexport function loadSESDeploySuccess(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 269942218) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _subscriber = sc_0.loadAddress();\n    return { $$type: 'SESDeploySuccess' as const, queryId: _queryId, subscriber: _subscriber };\n}\n\nfunction loadTupleSESDeploySuccess(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _subscriber = source.readAddress();\n    return { $$type: 'SESDeploySuccess' as const, queryId: _queryId, subscriber: _subscriber };\n}\n\nfunction storeTupleSESDeploySuccess(source: SESDeploySuccess) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeAddress(source.subscriber);\n    return builder.build();\n}\n\nfunction dictValueParserSESDeploySuccess(): DictionaryValue<SESDeploySuccess> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSESDeploySuccess(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSESDeploySuccess(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SESSubscribe = {\n    $$type: 'SESSubscribe';\n    queryId: bigint;\n    notificationsCount: bigint;\n}\n\nexport function storeSESSubscribe(src: SESSubscribe) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(1533823831, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeInt(src.notificationsCount, 257);\n    };\n}\n\nexport function loadSESSubscribe(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 1533823831) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _notificationsCount = sc_0.loadIntBig(257);\n    return { $$type: 'SESSubscribe' as const, queryId: _queryId, notificationsCount: _notificationsCount };\n}\n\nfunction loadTupleSESSubscribe(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _notificationsCount = source.readBigNumber();\n    return { $$type: 'SESSubscribe' as const, queryId: _queryId, notificationsCount: _notificationsCount };\n}\n\nfunction storeTupleSESSubscribe(source: SESSubscribe) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeNumber(source.notificationsCount);\n    return builder.build();\n}\n\nfunction dictValueParserSESSubscribe(): DictionaryValue<SESSubscribe> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSESSubscribe(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSESSubscribe(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type DSTTopUpSubscription = {\n    $$type: 'DSTTopUpSubscription';\n    queryId: bigint;\n    subscriber: Address;\n    batch: Address;\n    notificationsCount: bigint;\n}\n\nexport function storeDSTTopUpSubscription(src: DSTTopUpSubscription) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(495971614, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeAddress(src.subscriber);\n        b_0.storeAddress(src.batch);\n        b_0.storeInt(src.notificationsCount, 257);\n    };\n}\n\nexport function loadDSTTopUpSubscription(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 495971614) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _subscriber = sc_0.loadAddress();\n    let _batch = sc_0.loadAddress();\n    let _notificationsCount = sc_0.loadIntBig(257);\n    return { $$type: 'DSTTopUpSubscription' as const, queryId: _queryId, subscriber: _subscriber, batch: _batch, notificationsCount: _notificationsCount };\n}\n\nfunction loadTupleDSTTopUpSubscription(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _subscriber = source.readAddress();\n    let _batch = source.readAddress();\n    let _notificationsCount = source.readBigNumber();\n    return { $$type: 'DSTTopUpSubscription' as const, queryId: _queryId, subscriber: _subscriber, batch: _batch, notificationsCount: _notificationsCount };\n}\n\nfunction storeTupleDSTTopUpSubscription(source: DSTTopUpSubscription) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeAddress(source.subscriber);\n    builder.writeAddress(source.batch);\n    builder.writeNumber(source.notificationsCount);\n    return builder.build();\n}\n\nfunction dictValueParserDSTTopUpSubscription(): DictionaryValue<DSTTopUpSubscription> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeDSTTopUpSubscription(src)).endCell());\n        },\n        parse: (src) => {\n            return loadDSTTopUpSubscription(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SBTopUpSubscription = {\n    $$type: 'SBTopUpSubscription';\n    queryId: bigint;\n    session: Address;\n    notificationsCount: bigint;\n}\n\nexport function storeSBTopUpSubscription(src: SBTopUpSubscription) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(267884312, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeAddress(src.session);\n        b_0.storeInt(src.notificationsCount, 257);\n    };\n}\n\nexport function loadSBTopUpSubscription(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 267884312) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _session = sc_0.loadAddress();\n    let _notificationsCount = sc_0.loadIntBig(257);\n    return { $$type: 'SBTopUpSubscription' as const, queryId: _queryId, session: _session, notificationsCount: _notificationsCount };\n}\n\nfunction loadTupleSBTopUpSubscription(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _session = source.readAddress();\n    let _notificationsCount = source.readBigNumber();\n    return { $$type: 'SBTopUpSubscription' as const, queryId: _queryId, session: _session, notificationsCount: _notificationsCount };\n}\n\nfunction storeTupleSBTopUpSubscription(source: SBTopUpSubscription) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeAddress(source.session);\n    builder.writeNumber(source.notificationsCount);\n    return builder.build();\n}\n\nfunction dictValueParserSBTopUpSubscription(): DictionaryValue<SBTopUpSubscription> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSBTopUpSubscription(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSBTopUpSubscription(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SESSubscribeSuccess = {\n    $$type: 'SESSubscribeSuccess';\n    queryId: bigint;\n    remainingNotificationsCount: bigint;\n}\n\nexport function storeSESSubscribeSuccess(src: SESSubscribeSuccess) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(1400038355, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeInt(src.remainingNotificationsCount, 257);\n    };\n}\n\nexport function loadSESSubscribeSuccess(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 1400038355) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _remainingNotificationsCount = sc_0.loadIntBig(257);\n    return { $$type: 'SESSubscribeSuccess' as const, queryId: _queryId, remainingNotificationsCount: _remainingNotificationsCount };\n}\n\nfunction loadTupleSESSubscribeSuccess(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _remainingNotificationsCount = source.readBigNumber();\n    return { $$type: 'SESSubscribeSuccess' as const, queryId: _queryId, remainingNotificationsCount: _remainingNotificationsCount };\n}\n\nfunction storeTupleSESSubscribeSuccess(source: SESSubscribeSuccess) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeNumber(source.remainingNotificationsCount);\n    return builder.build();\n}\n\nfunction dictValueParserSESSubscribeSuccess(): DictionaryValue<SESSubscribeSuccess> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSESSubscribeSuccess(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSESSubscribeSuccess(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SESCandlestickPublishedNotification = {\n    $$type: 'SESCandlestickPublishedNotification';\n    queryId: bigint;\n    candlestick: Candlestick;\n    remainingNotificationsCount: bigint;\n}\n\nexport function storeSESCandlestickPublishedNotification(src: SESCandlestickPublishedNotification) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(3200926804, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.store(storeCandlestick(src.candlestick));\n        let b_1 = new Builder();\n        b_1.storeInt(src.remainingNotificationsCount, 257);\n        b_0.storeRef(b_1.endCell());\n    };\n}\n\nexport function loadSESCandlestickPublishedNotification(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 3200926804) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _candlestick = loadCandlestick(sc_0);\n    let sc_1 = sc_0.loadRef().beginParse();\n    let _remainingNotificationsCount = sc_1.loadIntBig(257);\n    return { $$type: 'SESCandlestickPublishedNotification' as const, queryId: _queryId, candlestick: _candlestick, remainingNotificationsCount: _remainingNotificationsCount };\n}\n\nfunction loadTupleSESCandlestickPublishedNotification(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    const _candlestick = loadTupleCandlestick(source.readTuple());\n    let _remainingNotificationsCount = source.readBigNumber();\n    return { $$type: 'SESCandlestickPublishedNotification' as const, queryId: _queryId, candlestick: _candlestick, remainingNotificationsCount: _remainingNotificationsCount };\n}\n\nfunction storeTupleSESCandlestickPublishedNotification(source: SESCandlestickPublishedNotification) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeTuple(storeTupleCandlestick(source.candlestick));\n    builder.writeNumber(source.remainingNotificationsCount);\n    return builder.build();\n}\n\nfunction dictValueParserSESCandlestickPublishedNotification(): DictionaryValue<SESCandlestickPublishedNotification> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSESCandlestickPublishedNotification(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSESCandlestickPublishedNotification(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SESUnsubscribedNotification = {\n    $$type: 'SESUnsubscribedNotification';\n    queryId: bigint;\n    remainingNotificationsCount: bigint;\n}\n\nexport function storeSESUnsubscribedNotification(src: SESUnsubscribedNotification) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(4092566650, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeInt(src.remainingNotificationsCount, 257);\n    };\n}\n\nexport function loadSESUnsubscribedNotification(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 4092566650) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _remainingNotificationsCount = sc_0.loadIntBig(257);\n    return { $$type: 'SESUnsubscribedNotification' as const, queryId: _queryId, remainingNotificationsCount: _remainingNotificationsCount };\n}\n\nfunction loadTupleSESUnsubscribedNotification(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _remainingNotificationsCount = source.readBigNumber();\n    return { $$type: 'SESUnsubscribedNotification' as const, queryId: _queryId, remainingNotificationsCount: _remainingNotificationsCount };\n}\n\nfunction storeTupleSESUnsubscribedNotification(source: SESUnsubscribedNotification) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeNumber(source.remainingNotificationsCount);\n    return builder.build();\n}\n\nfunction dictValueParserSESUnsubscribedNotification(): DictionaryValue<SESUnsubscribedNotification> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSESUnsubscribedNotification(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSESUnsubscribedNotification(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SESUnsubscribe = {\n    $$type: 'SESUnsubscribe';\n    queryId: bigint;\n}\n\nexport function storeSESUnsubscribe(src: SESUnsubscribe) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(2668625285, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadSESUnsubscribe(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 2668625285) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'SESUnsubscribe' as const, queryId: _queryId };\n}\n\nfunction loadTupleSESUnsubscribe(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'SESUnsubscribe' as const, queryId: _queryId };\n}\n\nfunction storeTupleSESUnsubscribe(source: SESUnsubscribe) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserSESUnsubscribe(): DictionaryValue<SESUnsubscribe> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSESUnsubscribe(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSESUnsubscribe(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SBUnsubscribe = {\n    $$type: 'SBUnsubscribe';\n    queryId: bigint;\n}\n\nexport function storeSBUnsubscribe(src: SBUnsubscribe) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(1095850324, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadSBUnsubscribe(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 1095850324) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'SBUnsubscribe' as const, queryId: _queryId };\n}\n\nfunction loadTupleSBUnsubscribe(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'SBUnsubscribe' as const, queryId: _queryId };\n}\n\nfunction storeTupleSBUnsubscribe(source: SBUnsubscribe) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserSBUnsubscribe(): DictionaryValue<SBUnsubscribe> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSBUnsubscribe(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSBUnsubscribe(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SESDestroy = {\n    $$type: 'SESDestroy';\n    queryId: bigint;\n}\n\nexport function storeSESDestroy(src: SESDestroy) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(2226780297, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadSESDestroy(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 2226780297) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'SESDestroy' as const, queryId: _queryId };\n}\n\nfunction loadTupleSESDestroy(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'SESDestroy' as const, queryId: _queryId };\n}\n\nfunction storeTupleSESDestroy(source: SESDestroy) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserSESDestroy(): DictionaryValue<SESDestroy> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSESDestroy(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSESDestroy(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SESDestroySuccess = {\n    $$type: 'SESDestroySuccess';\n    queryId: bigint;\n}\n\nexport function storeSESDestroySuccess(src: SESDestroySuccess) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(21916563, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadSESDestroySuccess(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 21916563) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'SESDestroySuccess' as const, queryId: _queryId };\n}\n\nfunction loadTupleSESDestroySuccess(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'SESDestroySuccess' as const, queryId: _queryId };\n}\n\nfunction storeTupleSESDestroySuccess(source: SESDestroySuccess) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserSESDestroySuccess(): DictionaryValue<SESDestroySuccess> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSESDestroySuccess(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSESDestroySuccess(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type BRGDeploy = {\n    $$type: 'BRGDeploy';\n    queryId: bigint;\n}\n\nexport function storeBRGDeploy(src: BRGDeploy) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(4195386677, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadBRGDeploy(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 4195386677) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'BRGDeploy' as const, queryId: _queryId };\n}\n\nfunction loadTupleBRGDeploy(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'BRGDeploy' as const, queryId: _queryId };\n}\n\nfunction storeTupleBRGDeploy(source: BRGDeploy) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserBRGDeploy(): DictionaryValue<BRGDeploy> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeBRGDeploy(src)).endCell());\n        },\n        parse: (src) => {\n            return loadBRGDeploy(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type BRGDeploySuccess = {\n    $$type: 'BRGDeploySuccess';\n    queryId: bigint;\n}\n\nexport function storeBRGDeploySuccess(src: BRGDeploySuccess) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(3142995347, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadBRGDeploySuccess(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 3142995347) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'BRGDeploySuccess' as const, queryId: _queryId };\n}\n\nfunction loadTupleBRGDeploySuccess(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'BRGDeploySuccess' as const, queryId: _queryId };\n}\n\nfunction storeTupleBRGDeploySuccess(source: BRGDeploySuccess) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserBRGDeploySuccess(): DictionaryValue<BRGDeploySuccess> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeBRGDeploySuccess(src)).endCell());\n        },\n        parse: (src) => {\n            return loadBRGDeploySuccess(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type BRGDeployBroker = {\n    $$type: 'BRGDeployBroker';\n    queryId: bigint;\n    stream: Address;\n}\n\nexport function storeBRGDeployBroker(src: BRGDeployBroker) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(298971134, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeAddress(src.stream);\n    };\n}\n\nexport function loadBRGDeployBroker(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 298971134) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _stream = sc_0.loadAddress();\n    return { $$type: 'BRGDeployBroker' as const, queryId: _queryId, stream: _stream };\n}\n\nfunction loadTupleBRGDeployBroker(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _stream = source.readAddress();\n    return { $$type: 'BRGDeployBroker' as const, queryId: _queryId, stream: _stream };\n}\n\nfunction storeTupleBRGDeployBroker(source: BRGDeployBroker) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeAddress(source.stream);\n    return builder.build();\n}\n\nfunction dictValueParserBRGDeployBroker(): DictionaryValue<BRGDeployBroker> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeBRGDeployBroker(src)).endCell());\n        },\n        parse: (src) => {\n            return loadBRGDeployBroker(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type BRKDeploy = {\n    $$type: 'BRKDeploy';\n    queryId: bigint;\n}\n\nexport function storeBRKDeploy(src: BRKDeploy) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(1366331229, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadBRKDeploy(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 1366331229) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'BRKDeploy' as const, queryId: _queryId };\n}\n\nfunction loadTupleBRKDeploy(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'BRKDeploy' as const, queryId: _queryId };\n}\n\nfunction storeTupleBRKDeploy(source: BRKDeploy) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserBRKDeploy(): DictionaryValue<BRKDeploy> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeBRKDeploy(src)).endCell());\n        },\n        parse: (src) => {\n            return loadBRKDeploy(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type BRKDeploySuccess = {\n    $$type: 'BRKDeploySuccess';\n    queryId: bigint;\n    stream: Address;\n}\n\nexport function storeBRKDeploySuccess(src: BRKDeploySuccess) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(2536416450, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeAddress(src.stream);\n    };\n}\n\nexport function loadBRKDeploySuccess(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 2536416450) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _stream = sc_0.loadAddress();\n    return { $$type: 'BRKDeploySuccess' as const, queryId: _queryId, stream: _stream };\n}\n\nfunction loadTupleBRKDeploySuccess(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _stream = source.readAddress();\n    return { $$type: 'BRKDeploySuccess' as const, queryId: _queryId, stream: _stream };\n}\n\nfunction storeTupleBRKDeploySuccess(source: BRKDeploySuccess) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeAddress(source.stream);\n    return builder.build();\n}\n\nfunction dictValueParserBRKDeploySuccess(): DictionaryValue<BRKDeploySuccess> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeBRKDeploySuccess(src)).endCell());\n        },\n        parse: (src) => {\n            return loadBRKDeploySuccess(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type BRGDeployBrokerSuccess = {\n    $$type: 'BRGDeployBrokerSuccess';\n    queryId: bigint;\n    broker: Address;\n}\n\nexport function storeBRGDeployBrokerSuccess(src: BRGDeployBrokerSuccess) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(4042145317, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeAddress(src.broker);\n    };\n}\n\nexport function loadBRGDeployBrokerSuccess(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 4042145317) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _broker = sc_0.loadAddress();\n    return { $$type: 'BRGDeployBrokerSuccess' as const, queryId: _queryId, broker: _broker };\n}\n\nfunction loadTupleBRGDeployBrokerSuccess(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _broker = source.readAddress();\n    return { $$type: 'BRGDeployBrokerSuccess' as const, queryId: _queryId, broker: _broker };\n}\n\nfunction storeTupleBRGDeployBrokerSuccess(source: BRGDeployBrokerSuccess) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeAddress(source.broker);\n    return builder.build();\n}\n\nfunction dictValueParserBRGDeployBrokerSuccess(): DictionaryValue<BRGDeployBrokerSuccess> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeBRGDeployBrokerSuccess(src)).endCell());\n        },\n        parse: (src) => {\n            return loadBRGDeployBrokerSuccess(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type BRGDeployAccount = {\n    $$type: 'BRGDeployAccount';\n    queryId: bigint;\n}\n\nexport function storeBRGDeployAccount(src: BRGDeployAccount) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(3233956202, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadBRGDeployAccount(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 3233956202) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'BRGDeployAccount' as const, queryId: _queryId };\n}\n\nfunction loadTupleBRGDeployAccount(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'BRGDeployAccount' as const, queryId: _queryId };\n}\n\nfunction storeTupleBRGDeployAccount(source: BRGDeployAccount) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserBRGDeployAccount(): DictionaryValue<BRGDeployAccount> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeBRGDeployAccount(src)).endCell());\n        },\n        parse: (src) => {\n            return loadBRGDeployAccount(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type BRADeploy = {\n    $$type: 'BRADeploy';\n    queryId: bigint;\n}\n\nexport function storeBRADeploy(src: BRADeploy) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(1181556865, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadBRADeploy(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 1181556865) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'BRADeploy' as const, queryId: _queryId };\n}\n\nfunction loadTupleBRADeploy(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'BRADeploy' as const, queryId: _queryId };\n}\n\nfunction storeTupleBRADeploy(source: BRADeploy) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserBRADeploy(): DictionaryValue<BRADeploy> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeBRADeploy(src)).endCell());\n        },\n        parse: (src) => {\n            return loadBRADeploy(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type BRADeploySuccess = {\n    $$type: 'BRADeploySuccess';\n    queryId: bigint;\n    trader: Address;\n}\n\nexport function storeBRADeploySuccess(src: BRADeploySuccess) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(3517832790, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeAddress(src.trader);\n    };\n}\n\nexport function loadBRADeploySuccess(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 3517832790) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _trader = sc_0.loadAddress();\n    return { $$type: 'BRADeploySuccess' as const, queryId: _queryId, trader: _trader };\n}\n\nfunction loadTupleBRADeploySuccess(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _trader = source.readAddress();\n    return { $$type: 'BRADeploySuccess' as const, queryId: _queryId, trader: _trader };\n}\n\nfunction storeTupleBRADeploySuccess(source: BRADeploySuccess) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeAddress(source.trader);\n    return builder.build();\n}\n\nfunction dictValueParserBRADeploySuccess(): DictionaryValue<BRADeploySuccess> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeBRADeploySuccess(src)).endCell());\n        },\n        parse: (src) => {\n            return loadBRADeploySuccess(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type BRGDeployAccountSuccess = {\n    $$type: 'BRGDeployAccountSuccess';\n    queryId: bigint;\n    account: Address;\n}\n\nexport function storeBRGDeployAccountSuccess(src: BRGDeployAccountSuccess) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(1962963078, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeAddress(src.account);\n    };\n}\n\nexport function loadBRGDeployAccountSuccess(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 1962963078) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _account = sc_0.loadAddress();\n    return { $$type: 'BRGDeployAccountSuccess' as const, queryId: _queryId, account: _account };\n}\n\nfunction loadTupleBRGDeployAccountSuccess(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _account = source.readAddress();\n    return { $$type: 'BRGDeployAccountSuccess' as const, queryId: _queryId, account: _account };\n}\n\nfunction storeTupleBRGDeployAccountSuccess(source: BRGDeployAccountSuccess) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeAddress(source.account);\n    return builder.build();\n}\n\nfunction dictValueParserBRGDeployAccountSuccess(): DictionaryValue<BRGDeployAccountSuccess> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeBRGDeployAccountSuccess(src)).endCell());\n        },\n        parse: (src) => {\n            return loadBRGDeployAccountSuccess(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type BRKDeposit = {\n    $$type: 'BRKDeposit';\n    queryId: bigint;\n}\n\nexport function storeBRKDeposit(src: BRKDeposit) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(2141827764, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadBRKDeposit(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 2141827764) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'BRKDeposit' as const, queryId: _queryId };\n}\n\nfunction loadTupleBRKDeposit(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'BRKDeposit' as const, queryId: _queryId };\n}\n\nfunction storeTupleBRKDeposit(source: BRKDeposit) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserBRKDeposit(): DictionaryValue<BRKDeposit> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeBRKDeposit(src)).endCell());\n        },\n        parse: (src) => {\n            return loadBRKDeposit(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type BRKDepositSuccess = {\n    $$type: 'BRKDepositSuccess';\n    queryId: bigint;\n}\n\nexport function storeBRKDepositSuccess(src: BRKDepositSuccess) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(2064422216, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadBRKDepositSuccess(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 2064422216) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'BRKDepositSuccess' as const, queryId: _queryId };\n}\n\nfunction loadTupleBRKDepositSuccess(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'BRKDepositSuccess' as const, queryId: _queryId };\n}\n\nfunction storeTupleBRKDepositSuccess(source: BRKDepositSuccess) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserBRKDepositSuccess(): DictionaryValue<BRKDepositSuccess> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeBRKDepositSuccess(src)).endCell());\n        },\n        parse: (src) => {\n            return loadBRKDepositSuccess(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type BRKWithdraw = {\n    $$type: 'BRKWithdraw';\n    queryId: bigint;\n}\n\nexport function storeBRKWithdraw(src: BRKWithdraw) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(550691255, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadBRKWithdraw(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 550691255) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'BRKWithdraw' as const, queryId: _queryId };\n}\n\nfunction loadTupleBRKWithdraw(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'BRKWithdraw' as const, queryId: _queryId };\n}\n\nfunction storeTupleBRKWithdraw(source: BRKWithdraw) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserBRKWithdraw(): DictionaryValue<BRKWithdraw> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeBRKWithdraw(src)).endCell());\n        },\n        parse: (src) => {\n            return loadBRKWithdraw(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type BRKWithdrawSuccess = {\n    $$type: 'BRKWithdrawSuccess';\n    queryId: bigint;\n}\n\nexport function storeBRKWithdrawSuccess(src: BRKWithdrawSuccess) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(2654800410, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadBRKWithdrawSuccess(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 2654800410) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'BRKWithdrawSuccess' as const, queryId: _queryId };\n}\n\nfunction loadTupleBRKWithdrawSuccess(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'BRKWithdrawSuccess' as const, queryId: _queryId };\n}\n\nfunction storeTupleBRKWithdrawSuccess(source: BRKWithdrawSuccess) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserBRKWithdrawSuccess(): DictionaryValue<BRKWithdrawSuccess> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeBRKWithdrawSuccess(src)).endCell());\n        },\n        parse: (src) => {\n            return loadBRKWithdrawSuccess(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type Fraction = {\n    $$type: 'Fraction';\n    nominator: bigint;\n    denominator: bigint;\n}\n\nexport function storeFraction(src: Fraction) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeInt(src.nominator, 257);\n        b_0.storeInt(src.denominator, 257);\n    };\n}\n\nexport function loadFraction(slice: Slice) {\n    let sc_0 = slice;\n    let _nominator = sc_0.loadIntBig(257);\n    let _denominator = sc_0.loadIntBig(257);\n    return { $$type: 'Fraction' as const, nominator: _nominator, denominator: _denominator };\n}\n\nfunction loadTupleFraction(source: TupleReader) {\n    let _nominator = source.readBigNumber();\n    let _denominator = source.readBigNumber();\n    return { $$type: 'Fraction' as const, nominator: _nominator, denominator: _denominator };\n}\n\nfunction storeTupleFraction(source: Fraction) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.nominator);\n    builder.writeNumber(source.denominator);\n    return builder.build();\n}\n\nfunction dictValueParserFraction(): DictionaryValue<Fraction> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeFraction(src)).endCell());\n        },\n        parse: (src) => {\n            return loadFraction(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type CashOrNothingOptionDraftAgreement = {\n    $$type: 'CashOrNothingOptionDraftAgreement';\n    holder: Address;\n    initiation: bigint;\n    expiration: bigint;\n    optionType: boolean;\n    investment: bigint;\n}\n\nexport function storeCashOrNothingOptionDraftAgreement(src: CashOrNothingOptionDraftAgreement) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeAddress(src.holder);\n        b_0.storeInt(src.initiation, 257);\n        b_0.storeInt(src.expiration, 257);\n        b_0.storeBit(src.optionType);\n        let b_1 = new Builder();\n        b_1.storeInt(src.investment, 257);\n        b_0.storeRef(b_1.endCell());\n    };\n}\n\nexport function loadCashOrNothingOptionDraftAgreement(slice: Slice) {\n    let sc_0 = slice;\n    let _holder = sc_0.loadAddress();\n    let _initiation = sc_0.loadIntBig(257);\n    let _expiration = sc_0.loadIntBig(257);\n    let _optionType = sc_0.loadBit();\n    let sc_1 = sc_0.loadRef().beginParse();\n    let _investment = sc_1.loadIntBig(257);\n    return { $$type: 'CashOrNothingOptionDraftAgreement' as const, holder: _holder, initiation: _initiation, expiration: _expiration, optionType: _optionType, investment: _investment };\n}\n\nfunction loadTupleCashOrNothingOptionDraftAgreement(source: TupleReader) {\n    let _holder = source.readAddress();\n    let _initiation = source.readBigNumber();\n    let _expiration = source.readBigNumber();\n    let _optionType = source.readBoolean();\n    let _investment = source.readBigNumber();\n    return { $$type: 'CashOrNothingOptionDraftAgreement' as const, holder: _holder, initiation: _initiation, expiration: _expiration, optionType: _optionType, investment: _investment };\n}\n\nfunction storeTupleCashOrNothingOptionDraftAgreement(source: CashOrNothingOptionDraftAgreement) {\n    let builder = new TupleBuilder();\n    builder.writeAddress(source.holder);\n    builder.writeNumber(source.initiation);\n    builder.writeNumber(source.expiration);\n    builder.writeBoolean(source.optionType);\n    builder.writeNumber(source.investment);\n    return builder.build();\n}\n\nfunction dictValueParserCashOrNothingOptionDraftAgreement(): DictionaryValue<CashOrNothingOptionDraftAgreement> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeCashOrNothingOptionDraftAgreement(src)).endCell());\n        },\n        parse: (src) => {\n            return loadCashOrNothingOptionDraftAgreement(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type BrokerDeployOption = {\n    $$type: 'BrokerDeployOption';\n    queryId: bigint;\n    draft: CashOrNothingOptionDraftAgreement;\n}\n\nexport function storeBrokerDeployOption(src: BrokerDeployOption) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(1174791129, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.store(storeCashOrNothingOptionDraftAgreement(src.draft));\n    };\n}\n\nexport function loadBrokerDeployOption(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 1174791129) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _draft = loadCashOrNothingOptionDraftAgreement(sc_0);\n    return { $$type: 'BrokerDeployOption' as const, queryId: _queryId, draft: _draft };\n}\n\nfunction loadTupleBrokerDeployOption(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    const _draft = loadTupleCashOrNothingOptionDraftAgreement(source.readTuple());\n    return { $$type: 'BrokerDeployOption' as const, queryId: _queryId, draft: _draft };\n}\n\nfunction storeTupleBrokerDeployOption(source: BrokerDeployOption) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeTuple(storeTupleCashOrNothingOptionDraftAgreement(source.draft));\n    return builder.build();\n}\n\nfunction dictValueParserBrokerDeployOption(): DictionaryValue<BrokerDeployOption> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeBrokerDeployOption(src)).endCell());\n        },\n        parse: (src) => {\n            return loadBrokerDeployOption(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type BrokerDeployOptionSuccess = {\n    $$type: 'BrokerDeployOptionSuccess';\n    queryId: bigint;\n    stream: Address;\n    option: Address;\n}\n\nexport function storeBrokerDeployOptionSuccess(src: BrokerDeployOptionSuccess) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(2438374427, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeAddress(src.stream);\n        b_0.storeAddress(src.option);\n    };\n}\n\nexport function loadBrokerDeployOptionSuccess(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 2438374427) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _stream = sc_0.loadAddress();\n    let _option = sc_0.loadAddress();\n    return { $$type: 'BrokerDeployOptionSuccess' as const, queryId: _queryId, stream: _stream, option: _option };\n}\n\nfunction loadTupleBrokerDeployOptionSuccess(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _stream = source.readAddress();\n    let _option = source.readAddress();\n    return { $$type: 'BrokerDeployOptionSuccess' as const, queryId: _queryId, stream: _stream, option: _option };\n}\n\nfunction storeTupleBrokerDeployOptionSuccess(source: BrokerDeployOptionSuccess) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeAddress(source.stream);\n    builder.writeAddress(source.option);\n    return builder.build();\n}\n\nfunction dictValueParserBrokerDeployOptionSuccess(): DictionaryValue<BrokerDeployOptionSuccess> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeBrokerDeployOptionSuccess(src)).endCell());\n        },\n        parse: (src) => {\n            return loadBrokerDeployOptionSuccess(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type CashOrNothingOptionDeploy = {\n    $$type: 'CashOrNothingOptionDeploy';\n    queryId: bigint;\n    stream: Address;\n    agreement: CashOrNothingOptionAgreement;\n}\n\nexport function storeCashOrNothingOptionDeploy(src: CashOrNothingOptionDeploy) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(3343868548, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeAddress(src.stream);\n        let b_1 = new Builder();\n        b_1.store(storeCashOrNothingOptionAgreement(src.agreement));\n        b_0.storeRef(b_1.endCell());\n    };\n}\n\nexport function loadCashOrNothingOptionDeploy(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 3343868548) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _stream = sc_0.loadAddress();\n    let sc_1 = sc_0.loadRef().beginParse();\n    let _agreement = loadCashOrNothingOptionAgreement(sc_1);\n    return { $$type: 'CashOrNothingOptionDeploy' as const, queryId: _queryId, stream: _stream, agreement: _agreement };\n}\n\nfunction loadTupleCashOrNothingOptionDeploy(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _stream = source.readAddress();\n    const _agreement = loadTupleCashOrNothingOptionAgreement(source.readTuple());\n    return { $$type: 'CashOrNothingOptionDeploy' as const, queryId: _queryId, stream: _stream, agreement: _agreement };\n}\n\nfunction storeTupleCashOrNothingOptionDeploy(source: CashOrNothingOptionDeploy) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeAddress(source.stream);\n    builder.writeTuple(storeTupleCashOrNothingOptionAgreement(source.agreement));\n    return builder.build();\n}\n\nfunction dictValueParserCashOrNothingOptionDeploy(): DictionaryValue<CashOrNothingOptionDeploy> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeCashOrNothingOptionDeploy(src)).endCell());\n        },\n        parse: (src) => {\n            return loadCashOrNothingOptionDeploy(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type CashOrNothingOptionDeploySuccess = {\n    $$type: 'CashOrNothingOptionDeploySuccess';\n    queryId: bigint;\n    optionId: bigint;\n    holder: Address;\n}\n\nexport function storeCashOrNothingOptionDeploySuccess(src: CashOrNothingOptionDeploySuccess) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(2669413677, 32);\n        b_0.storeUint(src.queryId, 64);\n        b_0.storeInt(src.optionId, 257);\n        b_0.storeAddress(src.holder);\n    };\n}\n\nexport function loadCashOrNothingOptionDeploySuccess(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 2669413677) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    let _optionId = sc_0.loadIntBig(257);\n    let _holder = sc_0.loadAddress();\n    return { $$type: 'CashOrNothingOptionDeploySuccess' as const, queryId: _queryId, optionId: _optionId, holder: _holder };\n}\n\nfunction loadTupleCashOrNothingOptionDeploySuccess(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    let _optionId = source.readBigNumber();\n    let _holder = source.readAddress();\n    return { $$type: 'CashOrNothingOptionDeploySuccess' as const, queryId: _queryId, optionId: _optionId, holder: _holder };\n}\n\nfunction storeTupleCashOrNothingOptionDeploySuccess(source: CashOrNothingOptionDeploySuccess) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    builder.writeNumber(source.optionId);\n    builder.writeAddress(source.holder);\n    return builder.build();\n}\n\nfunction dictValueParserCashOrNothingOptionDeploySuccess(): DictionaryValue<CashOrNothingOptionDeploySuccess> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeCashOrNothingOptionDeploySuccess(src)).endCell());\n        },\n        parse: (src) => {\n            return loadCashOrNothingOptionDeploySuccess(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type CashOrNothingOptionSettledInMoneyNotification = {\n    $$type: 'CashOrNothingOptionSettledInMoneyNotification';\n    queryId: bigint;\n}\n\nexport function storeCashOrNothingOptionSettledInMoneyNotification(src: CashOrNothingOptionSettledInMoneyNotification) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(4281832964, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadCashOrNothingOptionSettledInMoneyNotification(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 4281832964) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'CashOrNothingOptionSettledInMoneyNotification' as const, queryId: _queryId };\n}\n\nfunction loadTupleCashOrNothingOptionSettledInMoneyNotification(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'CashOrNothingOptionSettledInMoneyNotification' as const, queryId: _queryId };\n}\n\nfunction storeTupleCashOrNothingOptionSettledInMoneyNotification(source: CashOrNothingOptionSettledInMoneyNotification) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserCashOrNothingOptionSettledInMoneyNotification(): DictionaryValue<CashOrNothingOptionSettledInMoneyNotification> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeCashOrNothingOptionSettledInMoneyNotification(src)).endCell());\n        },\n        parse: (src) => {\n            return loadCashOrNothingOptionSettledInMoneyNotification(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type CashOrNothingOptionSettledOutMoneyNotification = {\n    $$type: 'CashOrNothingOptionSettledOutMoneyNotification';\n    queryId: bigint;\n}\n\nexport function storeCashOrNothingOptionSettledOutMoneyNotification(src: CashOrNothingOptionSettledOutMoneyNotification) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(402709524, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadCashOrNothingOptionSettledOutMoneyNotification(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 402709524) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'CashOrNothingOptionSettledOutMoneyNotification' as const, queryId: _queryId };\n}\n\nfunction loadTupleCashOrNothingOptionSettledOutMoneyNotification(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'CashOrNothingOptionSettledOutMoneyNotification' as const, queryId: _queryId };\n}\n\nfunction storeTupleCashOrNothingOptionSettledOutMoneyNotification(source: CashOrNothingOptionSettledOutMoneyNotification) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserCashOrNothingOptionSettledOutMoneyNotification(): DictionaryValue<CashOrNothingOptionSettledOutMoneyNotification> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeCashOrNothingOptionSettledOutMoneyNotification(src)).endCell());\n        },\n        parse: (src) => {\n            return loadCashOrNothingOptionSettledOutMoneyNotification(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type CashOrNothingOptionSettledAtMoneyNotification = {\n    $$type: 'CashOrNothingOptionSettledAtMoneyNotification';\n    queryId: bigint;\n}\n\nexport function storeCashOrNothingOptionSettledAtMoneyNotification(src: CashOrNothingOptionSettledAtMoneyNotification) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(1344539513, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadCashOrNothingOptionSettledAtMoneyNotification(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 1344539513) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'CashOrNothingOptionSettledAtMoneyNotification' as const, queryId: _queryId };\n}\n\nfunction loadTupleCashOrNothingOptionSettledAtMoneyNotification(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'CashOrNothingOptionSettledAtMoneyNotification' as const, queryId: _queryId };\n}\n\nfunction storeTupleCashOrNothingOptionSettledAtMoneyNotification(source: CashOrNothingOptionSettledAtMoneyNotification) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserCashOrNothingOptionSettledAtMoneyNotification(): DictionaryValue<CashOrNothingOptionSettledAtMoneyNotification> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeCashOrNothingOptionSettledAtMoneyNotification(src)).endCell());\n        },\n        parse: (src) => {\n            return loadCashOrNothingOptionSettledAtMoneyNotification(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type CashOrNothingOptionAgreement = {\n    $$type: 'CashOrNothingOptionAgreement';\n    holder: Address;\n    writer: Address;\n    initiation: bigint;\n    expiration: bigint;\n    optionType: boolean;\n    investment: bigint;\n    payout: bigint;\n}\n\nexport function storeCashOrNothingOptionAgreement(src: CashOrNothingOptionAgreement) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeAddress(src.holder);\n        b_0.storeAddress(src.writer);\n        b_0.storeUint(src.initiation, 32);\n        b_0.storeUint(src.expiration, 32);\n        b_0.storeBit(src.optionType);\n        b_0.storeCoins(src.investment);\n        b_0.storeCoins(src.payout);\n    };\n}\n\nexport function loadCashOrNothingOptionAgreement(slice: Slice) {\n    let sc_0 = slice;\n    let _holder = sc_0.loadAddress();\n    let _writer = sc_0.loadAddress();\n    let _initiation = sc_0.loadUintBig(32);\n    let _expiration = sc_0.loadUintBig(32);\n    let _optionType = sc_0.loadBit();\n    let _investment = sc_0.loadCoins();\n    let _payout = sc_0.loadCoins();\n    return { $$type: 'CashOrNothingOptionAgreement' as const, holder: _holder, writer: _writer, initiation: _initiation, expiration: _expiration, optionType: _optionType, investment: _investment, payout: _payout };\n}\n\nfunction loadTupleCashOrNothingOptionAgreement(source: TupleReader) {\n    let _holder = source.readAddress();\n    let _writer = source.readAddress();\n    let _initiation = source.readBigNumber();\n    let _expiration = source.readBigNumber();\n    let _optionType = source.readBoolean();\n    let _investment = source.readBigNumber();\n    let _payout = source.readBigNumber();\n    return { $$type: 'CashOrNothingOptionAgreement' as const, holder: _holder, writer: _writer, initiation: _initiation, expiration: _expiration, optionType: _optionType, investment: _investment, payout: _payout };\n}\n\nfunction storeTupleCashOrNothingOptionAgreement(source: CashOrNothingOptionAgreement) {\n    let builder = new TupleBuilder();\n    builder.writeAddress(source.holder);\n    builder.writeAddress(source.writer);\n    builder.writeNumber(source.initiation);\n    builder.writeNumber(source.expiration);\n    builder.writeBoolean(source.optionType);\n    builder.writeNumber(source.investment);\n    builder.writeNumber(source.payout);\n    return builder.build();\n}\n\nfunction dictValueParserCashOrNothingOptionAgreement(): DictionaryValue<CashOrNothingOptionAgreement> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeCashOrNothingOptionAgreement(src)).endCell());\n        },\n        parse: (src) => {\n            return loadCashOrNothingOptionAgreement(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SubscriberDestroyedNotification = {\n    $$type: 'SubscriberDestroyedNotification';\n    queryId: bigint;\n}\n\nexport function storeSubscriberDestroyedNotification(src: SubscriberDestroyedNotification) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(2253786793, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadSubscriberDestroyedNotification(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 2253786793) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'SubscriberDestroyedNotification' as const, queryId: _queryId };\n}\n\nfunction loadTupleSubscriberDestroyedNotification(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'SubscriberDestroyedNotification' as const, queryId: _queryId };\n}\n\nfunction storeTupleSubscriberDestroyedNotification(source: SubscriberDestroyedNotification) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserSubscriberDestroyedNotification(): DictionaryValue<SubscriberDestroyedNotification> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSubscriberDestroyedNotification(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSubscriberDestroyedNotification(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SubscriberCheckTimeout = {\n    $$type: 'SubscriberCheckTimeout';\n    queryId: bigint;\n}\n\nexport function storeSubscriberCheckTimeout(src: SubscriberCheckTimeout) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(1397988627, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadSubscriberCheckTimeout(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 1397988627) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'SubscriberCheckTimeout' as const, queryId: _queryId };\n}\n\nfunction loadTupleSubscriberCheckTimeout(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'SubscriberCheckTimeout' as const, queryId: _queryId };\n}\n\nfunction storeTupleSubscriberCheckTimeout(source: SubscriberCheckTimeout) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserSubscriberCheckTimeout(): DictionaryValue<SubscriberCheckTimeout> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSubscriberCheckTimeout(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSubscriberCheckTimeout(src.loadRef().beginParse());\n        }\n    }\n}\n\nexport type SubscriberTimeoutExceeded = {\n    $$type: 'SubscriberTimeoutExceeded';\n    queryId: bigint;\n}\n\nexport function storeSubscriberTimeoutExceeded(src: SubscriberTimeoutExceeded) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeUint(2857706980, 32);\n        b_0.storeUint(src.queryId, 64);\n    };\n}\n\nexport function loadSubscriberTimeoutExceeded(slice: Slice) {\n    let sc_0 = slice;\n    if (sc_0.loadUint(32) !== 2857706980) { throw Error('Invalid prefix'); }\n    let _queryId = sc_0.loadUintBig(64);\n    return { $$type: 'SubscriberTimeoutExceeded' as const, queryId: _queryId };\n}\n\nfunction loadTupleSubscriberTimeoutExceeded(source: TupleReader) {\n    let _queryId = source.readBigNumber();\n    return { $$type: 'SubscriberTimeoutExceeded' as const, queryId: _queryId };\n}\n\nfunction storeTupleSubscriberTimeoutExceeded(source: SubscriberTimeoutExceeded) {\n    let builder = new TupleBuilder();\n    builder.writeNumber(source.queryId);\n    return builder.build();\n}\n\nfunction dictValueParserSubscriberTimeoutExceeded(): DictionaryValue<SubscriberTimeoutExceeded> {\n    return {\n        serialize: (src, builder) => {\n            builder.storeRef(beginCell().store(storeSubscriberTimeoutExceeded(src)).endCell());\n        },\n        parse: (src) => {\n            return loadSubscriberTimeoutExceeded(src.loadRef().beginParse());\n        }\n    }\n}\n\n type Broker_init_args = {\n    $$type: 'Broker_init_args';\n    owner: Address;\n    stream: Address;\n}\n\nfunction initBroker_init_args(src: Broker_init_args) {\n    return (builder: Builder) => {\n        let b_0 = builder;\n        b_0.storeAddress(src.owner);\n        b_0.storeAddress(src.stream);\n    };\n}\n\nasync function Broker_init(owner: Address, stream: Address) {\n    const __code = Cell.fromBase64('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');\n    const __system = Cell.fromBase64('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');\n    let builder = beginCell();\n    builder.storeRef(__system);\n    builder.storeUint(0, 1);\n    initBroker_init_args({ $$type: 'Broker_init_args', owner, stream })(builder);\n    const __data = builder.endCell();\n    return { code: __code, data: __data };\n}\n\nconst Broker_errors: { [key: number]: { message: string } } = {\n    2: { message: `Stack underflow` },\n    3: { message: `Stack overflow` },\n    4: { message: `Integer overflow` },\n    5: { message: `Integer out of expected range` },\n    6: { message: `Invalid opcode` },\n    7: { message: `Type check error` },\n    8: { message: `Cell overflow` },\n    9: { message: `Cell underflow` },\n    10: { message: `Dictionary error` },\n    13: { message: `Out of gas error` },\n    32: { message: `Method ID not found` },\n    34: { message: `Action is invalid or not supported` },\n    37: { message: `Not enough TON` },\n    38: { message: `Not enough extra-currencies` },\n    128: { message: `Null reference exception` },\n    129: { message: `Invalid serialization prefix` },\n    130: { message: `Invalid incoming message` },\n    131: { message: `Constraints error` },\n    132: { message: `Access denied` },\n    133: { message: `Contract stopped` },\n    134: { message: `Invalid argument` },\n    135: { message: `Code of a contract was not found` },\n    136: { message: `Invalid address` },\n    137: { message: `Masterchain support is not enabled for this contract` },\n}\n\nconst Broker_types: ABIType[] = [\n    {\"name\":\"StateInit\",\"header\":null,\"fields\":[{\"name\":\"code\",\"type\":{\"kind\":\"simple\",\"type\":\"cell\",\"optional\":false}},{\"name\":\"data\",\"type\":{\"kind\":\"simple\",\"type\":\"cell\",\"optional\":false}}]},\n    {\"name\":\"Context\",\"header\":null,\"fields\":[{\"name\":\"bounced\",\"type\":{\"kind\":\"simple\",\"type\":\"bool\",\"optional\":false}},{\"name\":\"sender\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}},{\"name\":\"value\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}},{\"name\":\"raw\",\"type\":{\"kind\":\"simple\",\"type\":\"slice\",\"optional\":false}}]},\n    {\"name\":\"SendParameters\",\"header\":null,\"fields\":[{\"name\":\"bounce\",\"type\":{\"kind\":\"simple\",\"type\":\"bool\",\"optional\":false}},{\"name\":\"to\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}},{\"name\":\"value\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}},{\"name\":\"mode\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}},{\"name\":\"body\",\"type\":{\"kind\":\"simple\",\"type\":\"cell\",\"optional\":true}},{\"name\":\"code\",\"type\":{\"kind\":\"simple\",\"type\":\"cell\",\"optional\":true}},{\"name\":\"data\",\"type\":{\"kind\":\"simple\",\"type\":\"cell\",\"optional\":true}}]},\n    {\"name\":\"DSTDeploy\",\"header\":306133030,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"DSTDeploySuccess\",\"header\":3957924127,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"DSTDeployBatch\",\"header\":3012477066,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"DSTDeployBatchSuccess\",\"header\":1261138638,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"batch\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}}]},\n    {\"name\":\"DSTDeploySession\",\"header\":1658160529,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"DSTDeploySessionSuccess\",\"header\":3452518278,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"session\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}}]},\n    {\"name\":\"DSTSubscribe\",\"header\":3216336466,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"subscriber\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}},{\"name\":\"notificationsCount\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}}]},\n    {\"name\":\"DSTSubscribeSuccess\",\"header\":3770107736,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"batch\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}},{\"name\":\"remainingNotificationsCount\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}}]},\n    {\"name\":\"Candlestick\",\"header\":null,\"fields\":[{\"name\":\"start\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}},{\"name\":\"end\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}},{\"name\":\"open\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}},{\"name\":\"close\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}},{\"name\":\"high\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}},{\"name\":\"low\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}}]},\n    {\"name\":\"DSTPublishCandlestick\",\"header\":990592317,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"candlestick\",\"type\":{\"kind\":\"simple\",\"type\":\"Candlestick\",\"optional\":false}}]},\n    {\"name\":\"DSTPublishCandlestickSuccess\",\"header\":215123525,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"DSTUnsubscribedNotification\",\"header\":1287102660,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"remainingNotificationsCount\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}}]},\n    {\"name\":\"SBDeploy\",\"header\":4267613765,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"SBDeploySuccess\",\"header\":1031311118,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"batchId\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}}]},\n    {\"name\":\"SBSubscribe\",\"header\":2001551522,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"session\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}},{\"name\":\"notificationsCount\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}}]},\n    {\"name\":\"SBSubscribeSuccess\",\"header\":4082513223,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"session\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}},{\"name\":\"remainingNotificationsCount\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}}]},\n    {\"name\":\"SBPublishCandlestick\",\"header\":4051052066,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"candlestick\",\"type\":{\"kind\":\"simple\",\"type\":\"Candlestick\",\"optional\":false}},{\"name\":\"publisher\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}}]},\n    {\"name\":\"SBCandlestickPublishedNotification\",\"header\":4175431181,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"candlestick\",\"type\":{\"kind\":\"simple\",\"type\":\"Candlestick\",\"optional\":false}},{\"name\":\"remainingNotificationsCount\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}}]},\n    {\"name\":\"SBUnsubscribedNotification\",\"header\":1003141156,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"session\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}},{\"name\":\"remainingNotificationsCount\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}}]},\n    {\"name\":\"SBPublishCandlestickSuccess\",\"header\":1027631690,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"SESDeploy\",\"header\":1372687436,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"SESDeploySuccess\",\"header\":269942218,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"subscriber\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}}]},\n    {\"name\":\"SESSubscribe\",\"header\":1533823831,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"notificationsCount\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}}]},\n    {\"name\":\"DSTTopUpSubscription\",\"header\":495971614,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"subscriber\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}},{\"name\":\"batch\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}},{\"name\":\"notificationsCount\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}}]},\n    {\"name\":\"SBTopUpSubscription\",\"header\":267884312,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"session\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}},{\"name\":\"notificationsCount\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}}]},\n    {\"name\":\"SESSubscribeSuccess\",\"header\":1400038355,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"remainingNotificationsCount\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}}]},\n    {\"name\":\"SESCandlestickPublishedNotification\",\"header\":3200926804,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"candlestick\",\"type\":{\"kind\":\"simple\",\"type\":\"Candlestick\",\"optional\":false}},{\"name\":\"remainingNotificationsCount\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}}]},\n    {\"name\":\"SESUnsubscribedNotification\",\"header\":4092566650,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"remainingNotificationsCount\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}}]},\n    {\"name\":\"SESUnsubscribe\",\"header\":2668625285,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"SBUnsubscribe\",\"header\":1095850324,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"SESDestroy\",\"header\":2226780297,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"SESDestroySuccess\",\"header\":21916563,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"BRGDeploy\",\"header\":4195386677,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"BRGDeploySuccess\",\"header\":3142995347,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"BRGDeployBroker\",\"header\":298971134,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"stream\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}}]},\n    {\"name\":\"BRKDeploy\",\"header\":1366331229,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"BRKDeploySuccess\",\"header\":2536416450,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"stream\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}}]},\n    {\"name\":\"BRGDeployBrokerSuccess\",\"header\":4042145317,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"broker\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}}]},\n    {\"name\":\"BRGDeployAccount\",\"header\":3233956202,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"BRADeploy\",\"header\":1181556865,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"BRADeploySuccess\",\"header\":3517832790,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"trader\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}}]},\n    {\"name\":\"BRGDeployAccountSuccess\",\"header\":1962963078,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"account\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}}]},\n    {\"name\":\"BRKDeposit\",\"header\":2141827764,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"BRKDepositSuccess\",\"header\":2064422216,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"BRKWithdraw\",\"header\":550691255,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"BRKWithdrawSuccess\",\"header\":2654800410,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"Fraction\",\"header\":null,\"fields\":[{\"name\":\"nominator\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}},{\"name\":\"denominator\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}}]},\n    {\"name\":\"CashOrNothingOptionDraftAgreement\",\"header\":null,\"fields\":[{\"name\":\"holder\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}},{\"name\":\"initiation\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}},{\"name\":\"expiration\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}},{\"name\":\"optionType\",\"type\":{\"kind\":\"simple\",\"type\":\"bool\",\"optional\":false}},{\"name\":\"investment\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}}]},\n    {\"name\":\"BrokerDeployOption\",\"header\":1174791129,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"draft\",\"type\":{\"kind\":\"simple\",\"type\":\"CashOrNothingOptionDraftAgreement\",\"optional\":false}}]},\n    {\"name\":\"BrokerDeployOptionSuccess\",\"header\":2438374427,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"stream\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}},{\"name\":\"option\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}}]},\n    {\"name\":\"CashOrNothingOptionDeploy\",\"header\":3343868548,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"stream\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}},{\"name\":\"agreement\",\"type\":{\"kind\":\"simple\",\"type\":\"CashOrNothingOptionAgreement\",\"optional\":false}}]},\n    {\"name\":\"CashOrNothingOptionDeploySuccess\",\"header\":2669413677,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}},{\"name\":\"optionId\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}},{\"name\":\"holder\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}}]},\n    {\"name\":\"CashOrNothingOptionSettledInMoneyNotification\",\"header\":4281832964,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"CashOrNothingOptionSettledOutMoneyNotification\",\"header\":402709524,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"CashOrNothingOptionSettledAtMoneyNotification\",\"header\":1344539513,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"CashOrNothingOptionAgreement\",\"header\":null,\"fields\":[{\"name\":\"holder\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}},{\"name\":\"writer\",\"type\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}},{\"name\":\"initiation\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":32}},{\"name\":\"expiration\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":32}},{\"name\":\"optionType\",\"type\":{\"kind\":\"simple\",\"type\":\"bool\",\"optional\":false}},{\"name\":\"investment\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":\"coins\"}},{\"name\":\"payout\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":\"coins\"}}]},\n    {\"name\":\"SubscriberDestroyedNotification\",\"header\":2253786793,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"SubscriberCheckTimeout\",\"header\":1397988627,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n    {\"name\":\"SubscriberTimeoutExceeded\",\"header\":2857706980,\"fields\":[{\"name\":\"queryId\",\"type\":{\"kind\":\"simple\",\"type\":\"uint\",\"optional\":false,\"format\":64}}]},\n]\n\nconst Broker_getters: ABIGetter[] = [\n    {\"name\":\"balance\",\"arguments\":[],\"returnType\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}},\n    {\"name\":\"storageReserve\",\"arguments\":[],\"returnType\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}},\n    {\"name\":\"depositDeposit\",\"arguments\":[],\"returnType\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}},\n    {\"name\":\"owner\",\"arguments\":[],\"returnType\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}},\n    {\"name\":\"stream\",\"arguments\":[],\"returnType\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}},\n    {\"name\":\"payout\",\"arguments\":[],\"returnType\":{\"kind\":\"simple\",\"type\":\"Fraction\",\"optional\":false}},\n    {\"name\":\"payoutRatio\",\"arguments\":[],\"returnType\":{\"kind\":\"simple\",\"type\":\"Fraction\",\"optional\":false}},\n    {\"name\":\"nextOptionId\",\"arguments\":[],\"returnType\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}},\n    {\"name\":\"optionAddress\",\"arguments\":[{\"name\":\"optionId\",\"type\":{\"kind\":\"simple\",\"type\":\"int\",\"optional\":false,\"format\":257}}],\"returnType\":{\"kind\":\"simple\",\"type\":\"address\",\"optional\":false}},\n]\n\nconst Broker_receivers: ABIReceiver[] = [\n    {\"receiver\":\"internal\",\"message\":{\"kind\":\"typed\",\"type\":\"BRKDeploy\"}},\n    {\"receiver\":\"internal\",\"message\":{\"kind\":\"typed\",\"type\":\"BRKDeposit\"}},\n    {\"receiver\":\"internal\",\"message\":{\"kind\":\"typed\",\"type\":\"BRKWithdraw\"}},\n    {\"receiver\":\"internal\",\"message\":{\"kind\":\"typed\",\"type\":\"BrokerDeployOption\"}},\n    {\"receiver\":\"internal\",\"message\":{\"kind\":\"typed\",\"type\":\"CashOrNothingOptionDeploySuccess\"}},\n    {\"receiver\":\"internal\",\"message\":{\"kind\":\"typed\",\"type\":\"CashOrNothingOptionSettledInMoneyNotification\"}},\n    {\"receiver\":\"internal\",\"message\":{\"kind\":\"typed\",\"type\":\"CashOrNothingOptionSettledOutMoneyNotification\"}},\n    {\"receiver\":\"internal\",\"message\":{\"kind\":\"typed\",\"type\":\"CashOrNothingOptionSettledAtMoneyNotification\"}},\n    {\"receiver\":\"internal\",\"message\":{\"kind\":\"typed\",\"type\":\"SubscriberDestroyedNotification\"}},\n]\n\nexport class Broker implements Contract {\n    \n    static async init(owner: Address, stream: Address) {\n        return await Broker_init(owner, stream);\n    }\n    \n    static async fromInit(owner: Address, stream: Address) {\n        const init = await Broker_init(owner, stream);\n        const address = contractAddress(0, init);\n        return new Broker(address, init);\n    }\n    \n    static fromAddress(address: Address) {\n        return new Broker(address);\n    }\n    \n    readonly address: Address; \n    readonly init?: { code: Cell, data: Cell };\n    readonly abi: ContractABI = {\n        types:  Broker_types,\n        getters: Broker_getters,\n        receivers: Broker_receivers,\n        errors: Broker_errors,\n    };\n    \n    private constructor(address: Address, init?: { code: Cell, data: Cell }) {\n        this.address = address;\n        this.init = init;\n    }\n    \n    async send(provider: ContractProvider, via: Sender, args: { value: bigint, bounce?: boolean| null | undefined }, message: BRKDeploy | BRKDeposit | BRKWithdraw | BrokerDeployOption | CashOrNothingOptionDeploySuccess | CashOrNothingOptionSettledInMoneyNotification | CashOrNothingOptionSettledOutMoneyNotification | CashOrNothingOptionSettledAtMoneyNotification | SubscriberDestroyedNotification) {\n        \n        let body: Cell | null = null;\n        if (message && typeof message === 'object' && !(message instanceof Slice) && message.$$type === 'BRKDeploy') {\n            body = beginCell().store(storeBRKDeploy(message)).endCell();\n        }\n        if (message && typeof message === 'object' && !(message instanceof Slice) && message.$$type === 'BRKDeposit') {\n            body = beginCell().store(storeBRKDeposit(message)).endCell();\n        }\n        if (message && typeof message === 'object' && !(message instanceof Slice) && message.$$type === 'BRKWithdraw') {\n            body = beginCell().store(storeBRKWithdraw(message)).endCell();\n        }\n        if (message && typeof message === 'object' && !(message instanceof Slice) && message.$$type === 'BrokerDeployOption') {\n            body = beginCell().store(storeBrokerDeployOption(message)).endCell();\n        }\n        if (message && typeof message === 'object' && !(message instanceof Slice) && message.$$type === 'CashOrNothingOptionDeploySuccess') {\n            body = beginCell().store(storeCashOrNothingOptionDeploySuccess(message)).endCell();\n        }\n        if (message && typeof message === 'object' && !(message instanceof Slice) && message.$$type === 'CashOrNothingOptionSettledInMoneyNotification') {\n            body = beginCell().store(storeCashOrNothingOptionSettledInMoneyNotification(message)).endCell();\n        }\n        if (message && typeof message === 'object' && !(message instanceof Slice) && message.$$type === 'CashOrNothingOptionSettledOutMoneyNotification') {\n            body = beginCell().store(storeCashOrNothingOptionSettledOutMoneyNotification(message)).endCell();\n        }\n        if (message && typeof message === 'object' && !(message instanceof Slice) && message.$$type === 'CashOrNothingOptionSettledAtMoneyNotification') {\n            body = beginCell().store(storeCashOrNothingOptionSettledAtMoneyNotification(message)).endCell();\n        }\n        if (message && typeof message === 'object' && !(message instanceof Slice) && message.$$type === 'SubscriberDestroyedNotification') {\n            body = beginCell().store(storeSubscriberDestroyedNotification(message)).endCell();\n        }\n        if (body === null) { throw new Error('Invalid message type'); }\n        \n        await provider.internal(via, { ...args, body: body });\n        \n    }\n    \n    async getBalance(provider: ContractProvider) {\n        let builder = new TupleBuilder();\n        let source = (await provider.get('balance', builder.build())).stack;\n        let result = source.readBigNumber();\n        return result;\n    }\n    \n    async getStorageReserve(provider: ContractProvider) {\n        let builder = new TupleBuilder();\n        let source = (await provider.get('storageReserve', builder.build())).stack;\n        let result = source.readBigNumber();\n        return result;\n    }\n    \n    async getDepositDeposit(provider: ContractProvider) {\n        let builder = new TupleBuilder();\n        let source = (await provider.get('depositDeposit', builder.build())).stack;\n        let result = source.readBigNumber();\n        return result;\n    }\n    \n    async getOwner(provider: ContractProvider) {\n        let builder = new TupleBuilder();\n        let source = (await provider.get('owner', builder.build())).stack;\n        let result = source.readAddress();\n        return result;\n    }\n    \n    async getStream(provider: ContractProvider) {\n        let builder = new TupleBuilder();\n        let source = (await provider.get('stream', builder.build())).stack;\n        let result = source.readAddress();\n        return result;\n    }\n    \n    async getPayout(provider: ContractProvider) {\n        let builder = new TupleBuilder();\n        let source = (await provider.get('payout', builder.build())).stack;\n        const result = loadTupleFraction(source);\n        return result;\n    }\n    \n    async getPayoutRatio(provider: ContractProvider) {\n        let builder = new TupleBuilder();\n        let source = (await provider.get('payoutRatio', builder.build())).stack;\n        const result = loadTupleFraction(source);\n        return result;\n    }\n    \n    async getNextOptionId(provider: ContractProvider) {\n        let builder = new TupleBuilder();\n        let source = (await provider.get('nextOptionId', builder.build())).stack;\n        let result = source.readBigNumber();\n        return result;\n    }\n    \n    async getOptionAddress(provider: ContractProvider, optionId: bigint) {\n        let builder = new TupleBuilder();\n        builder.writeNumber(optionId);\n        let source = (await provider.get('optionAddress', builder.build())).stack;\n        let result = source.readAddress();\n        return result;\n    }\n    \n}","import z from 'zod';\nimport { CHAIN } from '@/constants';\n\nexport const checkProofRequestSchema = z.object({\n  address: z.string(),\n  network: z.nativeEnum(CHAIN),\n  public_key: z.string(),\n  proof: z.object({\n    timestamp: z.number(),\n    domain: z.object({\n      lengthBytes: z.number(),\n      value: z.string(),\n    }),\n    payload: z.string(),\n    signature: z.string(),\n    state_init: z.string(),\n  }),\n});\n\nexport type CheckProofRequestDto = z.infer<typeof checkProofRequestSchema>;\n","import { CHAIN } from '@/constants';\nimport type { CheckProofRequestDto } from '@/dtos/ton-connect.dto';\nimport { TonApiService, TonProofService } from '@/services/index';\nimport { fromNano } from '@ton/ton';\nimport type { FastifyReply, FastifyRequest } from 'fastify';\n\nexport async function handleCheckProof(\n  request: FastifyRequest<{\n    Body: CheckProofRequestDto;\n  }>,\n  reply: FastifyReply,\n) {\n  try {\n    const client = TonApiService.create(CHAIN.TESTNET);\n    const service = new TonProofService();\n\n    const isValid = await service.checkProof(request.body, (address) =>\n      client.getWalletPublicKey(address),\n    );\n\n    if (!isValid) {\n      return reply.code(400).send({ message: 'Invalid proof' });\n    }\n\n    const token = request.server.jwt.verify(request.body.proof.payload);\n\n    if (!token.toString()) {\n      return reply.code(400).send({ message: 'Invalid token' });\n    }\n\n    const newToken = await reply.jwtSign(\n      {\n        address: request.body.address,\n        network: request.body.network,\n        name: 'Vladimir Starkov',\n        email: 'test@gmail.com',\n      },\n      { expiresIn: '180d' },\n    );\n\n    return reply.code(200).send({\n      message: 'Proof is valid',\n      token: newToken,\n    });\n  } catch (error) {\n    console.error(error);\n    return reply.code(400).send({ message: 'Invalid request', error });\n  }\n}\n\nexport async function handleGenerateProofPayload(request: FastifyRequest, reply: FastifyReply) {\n  try {\n    const service = new TonProofService();\n    const payload = service.generatePayload();\n\n    const token = await reply.jwtSign({ payload }, { expiresIn: '15m' });\n    return reply.code(200).send({\n      proofToken: token,\n    });\n  } catch (error) {\n    console.error(error);\n    return reply.code(400).send({ message: 'Invalid request', error });\n  }\n}\n\nexport async function handleAccountInfo(request: FastifyRequest, reply: FastifyReply) {\n  try {\n    // @ts-expect-error TODO: Fix this\n    const { address, network } = request.user;\n\n    const client = TonApiService.create(network);\n\n    const { account } = await client.getAccountInfo(address);\n    return reply.code(200).send({\n      address,\n      balance: fromNano(account.balance.coins),\n    });\n  } catch (error) {\n    console.error(error);\n    return reply.code(400).send({ message: 'Invalid request', error });\n  }\n}\n","import { checkProofRequestSchema } from '@/dtos/ton-connect.dto';\nimport {\n  handleAccountInfo,\n  handleCheckProof,\n  handleGenerateProofPayload,\n} from '@/handlers/ton-connect';\nimport type { FastifyPluginAsync } from 'fastify';\n\nconst routes: FastifyPluginAsync = async (server) => {\n  // Public routes\n  server.post(\n    '/check-proof',\n    {\n      schema: {\n        body: checkProofRequestSchema,\n      },\n    },\n    handleCheckProof,\n  );\n\n  server.post('/generate-proof-payload', {}, handleGenerateProofPayload);\n\n  // Protected routes\n  server.get(\n    '/account-info',\n    {\n      preHandler: async (request, reply) => {\n        try {\n          await request.jwtVerify();\n        } catch (err) {\n          reply.send(err);\n        }\n      },\n    },\n    handleAccountInfo,\n  );\n};\n\nexport default routes;\n","import type { FastifyPluginAsync } from 'fastify';\nimport market from './market';\nimport ton from './ton-connect';\n\nconst routes: FastifyPluginAsync = async (server) => {\n  await server.register(market);\n  await server.register(ton);\n};\n\nexport default routes;\n","import server from './server';\n\nprocess.on('unhandledRejection', (err) => {\n  console.error(err);\n  process.exit(1);\n});\n\nconst port = +server.config.API_PORT;\nconst host = server.config.API_HOST;\nawait server.listen({ host, port });\n\nfor (const signal of ['SIGINT', 'SIGTERM']) {\n  process.on(signal, () =>\n    server.close().then((err) => {\n      console.log(`close application on ${signal}`);\n      process.exit(err ? 1 : 0);\n    }),\n  );\n}\n"]}